=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\(auth)\forgot-password.tsx ===
import React, { useState } from "react";
import { StyleSheet, Text, View, TextInput, Pressable, Platform, KeyboardAvoidingView, ScrollView, ActivityIndicator } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { router } from "expo-router";
import { Feather } from "@expo/vector-icons";
import Animated, { FadeInDown } from "react-native-reanimated";
import Colors from "@/constants/colors";
import { useAuth } from "@/lib/auth-context";
import { useI18n } from "@/lib/i18n";

export default function ForgotPasswordScreen() {
  const insets = useSafeAreaInsets();
  const { forgotPassword } = useAuth();
  const { t } = useI18n();
  const [email, setEmail] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const [sent, setSent] = useState(false);

  const handleSend = async () => {
    if (!email.trim()) return;
    setError("");
    setLoading(true);
    const result = await forgotPassword(email.trim());
    setLoading(false);
    if (result.error) {
      setError(result.error);
    } else {
      setSent(true);
    }
  };

  if (sent) {
    return (
      <View style={[styles.container, { justifyContent: "center", paddingHorizontal: 28 }]}>
        <View style={styles.brandContainer}>
          <View style={[styles.successIcon]}>
            <Feather name="check-circle" size={48} color={Colors.light.success} />
          </View>
        </View>
        <Text style={[styles.title, { textAlign: "center" }]}>Email sent</Text>
        <Text style={[styles.subtitle, { textAlign: "center", marginBottom: 32 }]}>
          If an account with {email} exists, you will receive a password reset link.
        </Text>
        <Pressable
          style={({ pressed }) => [styles.submitButton, pressed && { opacity: 0.85 }]}
          onPress={() => router.replace("/(auth)/login")}
        >
          <Text style={styles.submitButtonText}>{t.auth.backToLogin}</Text>
        </Pressable>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      keyboardVerticalOffset={0}
    >
      <ScrollView
        contentContainerStyle={[
          styles.scrollContent,
          { paddingTop: Platform.OS === "web" ? 67 : insets.top + 20, paddingBottom: Platform.OS === "web" ? 34 : insets.bottom + 20 },
        ]}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      >
        <Animated.View entering={Platform.OS !== "web" ? FadeInDown.duration(400) : undefined}>
          <Pressable onPress={() => router.back()} style={styles.backBtn}>
            <Feather name="arrow-left" size={22} color={Colors.light.text} />
          </Pressable>

          <View style={styles.brandContainer}>
            <View style={styles.lockIcon}>
              <Feather name="key" size={28} color={Colors.light.primary} />
            </View>
          </View>

          <Text style={styles.title}>{t.auth.forgotTitle}</Text>
          <Text style={styles.subtitle}>{t.auth.forgotSubtitle}</Text>

          {!!error && (
            <View style={styles.errorBox}>
              <Feather name="alert-circle" size={14} color={Colors.light.error} />
              <Text style={styles.errorText}>{error}</Text>
            </View>
          )}

          <View style={styles.inputContainer}>
            <Feather name="mail" size={18} color={Colors.light.textTertiary} style={styles.inputIcon} />
            <TextInput
              style={styles.input}
              placeholder={t.auth.email}
              placeholderTextColor={Colors.light.textTertiary}
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
              autoCorrect={false}
              autoFocus
              testID="forgot-email"
            />
          </View>

          <Pressable
            style={({ pressed }) => [styles.submitButton, pressed && { opacity: 0.85 }, loading && { opacity: 0.6 }]}
            onPress={handleSend}
            disabled={loading || !email.trim()}
            testID="forgot-submit"
          >
            {loading ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <Text style={styles.submitButtonText}>{t.auth.sendReset}</Text>
            )}
          </Pressable>

          <View style={styles.loginRow}>
            <Text style={styles.loginLabel}>Remember your password?</Text>
            <Pressable onPress={() => router.replace("/(auth)/login")}>
              <Text style={styles.loginLink}>Sign In</Text>
            </Pressable>
          </View>
        </Animated.View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 28,
  },
  backBtn: {
    width: 40,
    height: 40,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 12,
  },
  brandContainer: {
    alignItems: "center",
    marginBottom: 28,
  },
  lockIcon: {
    width: 64,
    height: 64,
    borderRadius: 20,
    backgroundColor: "#FFF3E0",
    alignItems: "center",
    justifyContent: "center",
  },
  successIcon: {
    marginBottom: 16,
  },
  title: {
    fontFamily: "Rubik_700Bold",
    fontSize: 24,
    color: Colors.light.text,
    marginBottom: 8,
  },
  subtitle: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
    lineHeight: 20,
    marginBottom: 28,
  },
  errorBox: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    backgroundColor: "#FDECEA",
    borderRadius: 12,
    padding: 14,
    marginBottom: 16,
  },
  errorText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.error,
    flex: 1,
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: Colors.light.surface,
    borderWidth: 1.5,
    borderColor: Colors.light.border,
    borderRadius: 14,
    paddingHorizontal: 16,
    marginBottom: 24,
  },
  inputIcon: {
    marginRight: 12,
  },
  input: {
    flex: 1,
    fontFamily: "Rubik_400Regular",
    fontSize: 15,
    color: Colors.light.text,
    paddingVertical: 16,
  },
  submitButton: {
    backgroundColor: Colors.light.primary,
    borderRadius: 14,
    paddingVertical: 16,
    alignItems: "center",
    marginBottom: 24,
  },
  submitButtonText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 16,
    color: "#fff",
  },
  loginRow: {
    flexDirection: "row",
    justifyContent: "center",
    gap: 6,
  },
  loginLabel: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
  },
  loginLink: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 14,
    color: Colors.light.primary,
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\(auth)\login.tsx ===
import React, { useState } from "react";
import { StyleSheet, Text, View, TextInput, Pressable, Platform, KeyboardAvoidingView, ScrollView, ActivityIndicator } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { router } from "expo-router";
import { Feather } from "@expo/vector-icons";
import Animated, { FadeInDown } from "react-native-reanimated";
import Colors from "@/constants/colors";
import { useAuth } from "@/lib/auth-context";
import { useI18n } from "@/lib/i18n";

export default function LoginScreen() {
  const insets = useSafeAreaInsets();
  const { login } = useAuth();
  const { t } = useI18n();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const handleLogin = async () => {
    if (!email.trim() || !password.trim()) return;
    setError("");
    setLoading(true);
    const result = await login(email.trim(), password);
    setLoading(false);
    if (result.error) {
      setError(result.error);
    }
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      keyboardVerticalOffset={0}
    >
      <ScrollView
        contentContainerStyle={[
          styles.scrollContent,
          { paddingTop: Platform.OS === "web" ? 67 : insets.top + 40, paddingBottom: Platform.OS === "web" ? 34 : insets.bottom + 20 },
        ]}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      >
        <Animated.View entering={Platform.OS !== "web" ? FadeInDown.duration(400) : undefined}>
          <View style={styles.brandContainer}>
            <View style={styles.brandIcon}>
              <Feather name="target" size={32} color="#fff" />
            </View>
            <Text style={styles.brandName}>RIGOR</Text>
            <Text style={styles.brandTagline}>Discipline. Tracked.</Text>
          </View>

          <Text style={styles.title}>{t.auth.loginTitle}</Text>
          <Text style={styles.subtitle}>{t.auth.loginSubtitle}</Text>

          {!!error && (
            <View style={styles.errorBox}>
              <Feather name="alert-circle" size={14} color={Colors.light.error} />
              <Text style={styles.errorText}>{error}</Text>
            </View>
          )}

          <View style={styles.inputContainer}>
            <Feather name="mail" size={18} color={Colors.light.textTertiary} style={styles.inputIcon} />
            <TextInput
              style={styles.input}
              placeholder={t.auth.email}
              placeholderTextColor={Colors.light.textTertiary}
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
              autoCorrect={false}
              testID="login-email"
            />
          </View>

          <View style={styles.inputContainer}>
            <Feather name="lock" size={18} color={Colors.light.textTertiary} style={styles.inputIcon} />
            <TextInput
              style={[styles.input, { flex: 1 }]}
              placeholder={t.auth.password}
              placeholderTextColor={Colors.light.textTertiary}
              value={password}
              onChangeText={setPassword}
              secureTextEntry={!showPassword}
              autoCapitalize="none"
              testID="login-password"
            />
            <Pressable onPress={() => setShowPassword(!showPassword)} style={styles.eyeButton}>
              <Feather name={showPassword ? "eye-off" : "eye"} size={18} color={Colors.light.textTertiary} />
            </Pressable>
          </View>

          <Pressable onPress={() => router.push("/(auth)/forgot-password")} style={styles.forgotLink}>
            <Text style={styles.forgotText}>{t.auth.forgotPassword}</Text>
          </Pressable>

          <Pressable
            style={({ pressed }) => [styles.loginButton, pressed && { opacity: 0.85 }, loading && { opacity: 0.6 }]}
            onPress={handleLogin}
            disabled={loading || !email.trim() || !password.trim()}
            testID="login-submit"
          >
            {loading ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <Text style={styles.loginButtonText}>{t.auth.login}</Text>
            )}
          </Pressable>

          <View style={styles.signupRow}>
            <Text style={styles.signupLabel}>{t.auth.noAccount}</Text>
            <Pressable onPress={() => router.push("/(auth)/signup")} testID="go-to-signup">
              <Text style={styles.signupLink}>{t.auth.signup}</Text>
            </Pressable>
          </View>
        </Animated.View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 28,
    justifyContent: "center",
  },
  brandContainer: {
    alignItems: "center",
    marginBottom: 40,
  },
  brandIcon: {
    width: 64,
    height: 64,
    borderRadius: 20,
    backgroundColor: Colors.light.primary,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 16,
  },
  brandName: {
    fontFamily: "Rubik_800ExtraBold",
    fontSize: 32,
    color: Colors.light.text,
    letterSpacing: 4,
  },
  brandTagline: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
    marginTop: 4,
  },
  title: {
    fontFamily: "Rubik_700Bold",
    fontSize: 24,
    color: Colors.light.text,
    marginBottom: 6,
  },
  subtitle: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
    marginBottom: 28,
  },
  errorBox: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    backgroundColor: "#FDECEA",
    borderRadius: 12,
    padding: 14,
    marginBottom: 16,
  },
  errorText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.error,
    flex: 1,
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: Colors.light.surface,
    borderWidth: 1.5,
    borderColor: Colors.light.border,
    borderRadius: 14,
    paddingHorizontal: 16,
    marginBottom: 14,
  },
  inputIcon: {
    marginRight: 12,
  },
  input: {
    flex: 1,
    fontFamily: "Rubik_400Regular",
    fontSize: 15,
    color: Colors.light.text,
    paddingVertical: 16,
  },
  eyeButton: {
    padding: 8,
    marginLeft: 4,
  },
  forgotLink: {
    alignSelf: "flex-end",
    marginBottom: 24,
  },
  forgotText: {
    fontFamily: "Rubik_500Medium",
    fontSize: 13,
    color: Colors.light.primary,
  },
  loginButton: {
    backgroundColor: Colors.light.primary,
    borderRadius: 14,
    paddingVertical: 16,
    alignItems: "center",
    marginBottom: 24,
  },
  loginButtonText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 16,
    color: "#fff",
  },
  signupRow: {
    flexDirection: "row",
    justifyContent: "center",
    gap: 6,
  },
  signupLabel: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
  },
  signupLink: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 14,
    color: Colors.light.primary,
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\(auth)\signup.tsx ===
import React, { useState } from "react";
import { StyleSheet, Text, View, TextInput, Pressable, Platform, KeyboardAvoidingView, ScrollView, ActivityIndicator } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { router } from "expo-router";
import { Feather } from "@expo/vector-icons";
import Animated, { FadeInDown } from "react-native-reanimated";
import Colors from "@/constants/colors";
import { useAuth } from "@/lib/auth-context";
import { useI18n } from "@/lib/i18n";

export default function SignupScreen() {
  const insets = useSafeAreaInsets();
  const { signup } = useAuth();
  const { t, language } = useI18n();
  const [username, setUsername] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);
  const [confirmEmailSent, setConfirmEmailSent] = useState(false);

  const isUsernameValid = username.trim().length >= 3 && /^[a-zA-Z0-9_]+$/.test(username.trim());

  const handleSignup = async () => {
    if (!username.trim() || !email.trim() || !password.trim()) return;
    if (!isUsernameValid) {
      setError(language === "pt" ? "Nome de usuário deve ter pelo menos 3 caracteres (letras, números, _)" : "Username must be at least 3 characters (letters, numbers, _)");
      return;
    }
    if (password !== confirmPassword) {
      setError("Passwords don't match");
      return;
    }
    if (password.length < 6) {
      setError("Password must be at least 6 characters");
      return;
    }
    setError("");
    setLoading(true);
    const result = await signup(email.trim(), password, username.trim());
    setLoading(false);
    if (result.error) {
      setError(result.error);
    } else if (result.confirmEmail) {
      setConfirmEmailSent(true);
    }
  };

  if (confirmEmailSent) {
    return (
      <View style={[styles.container, { justifyContent: "center", paddingHorizontal: 28 }]}>
        <View style={styles.brandContainer}>
          <View style={[styles.brandIcon, { backgroundColor: Colors.light.success }]}>
            <Feather name="mail" size={32} color="#fff" />
          </View>
        </View>
        <Text style={[styles.title, { textAlign: "center" }]}>Check your email</Text>
        <Text style={[styles.subtitle, { textAlign: "center", marginBottom: 32 }]}>
          We sent a confirmation link to {email}. Open it to activate your account.
        </Text>
        <Pressable
          style={({ pressed }) => [styles.loginButton, pressed && { opacity: 0.85 }]}
          onPress={() => router.replace("/(auth)/login")}
        >
          <Text style={styles.loginButtonText}>Go to Login</Text>
        </Pressable>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      keyboardVerticalOffset={0}
    >
      <ScrollView
        contentContainerStyle={[
          styles.scrollContent,
          { paddingTop: Platform.OS === "web" ? 67 : insets.top + 20, paddingBottom: Platform.OS === "web" ? 34 : insets.bottom + 20 },
        ]}
        keyboardShouldPersistTaps="handled"
        showsVerticalScrollIndicator={false}
      >
        <Animated.View entering={Platform.OS !== "web" ? FadeInDown.duration(400) : undefined}>
          <Pressable onPress={() => router.back()} style={styles.backBtn}>
            <Feather name="arrow-left" size={22} color={Colors.light.text} />
          </Pressable>

          <View style={styles.brandContainer}>
            <View style={styles.brandIcon}>
              <Feather name="target" size={32} color="#fff" />
            </View>
          </View>

          <Text style={styles.title}>{t.auth.signupTitle}</Text>
          <Text style={styles.subtitle}>{t.auth.signupSubtitle}</Text>

          {!!error && (
            <View style={styles.errorBox}>
              <Feather name="alert-circle" size={14} color={Colors.light.error} />
              <Text style={styles.errorText}>{error}</Text>
            </View>
          )}

          <View style={styles.inputContainer}>
            <Feather name="user" size={18} color={Colors.light.textTertiary} style={styles.inputIcon} />
            <TextInput
              style={styles.input}
              placeholder={(t.auth as any).usernamePlaceholder}
              placeholderTextColor={Colors.light.textTertiary}
              value={username}
              onChangeText={(text) => setUsername(text.replace(/[^a-zA-Z0-9_]/g, ""))}
              autoCapitalize="none"
              autoCorrect={false}
              maxLength={20}
              testID="signup-username"
            />
          </View>

          <View style={styles.inputContainer}>
            <Feather name="mail" size={18} color={Colors.light.textTertiary} style={styles.inputIcon} />
            <TextInput
              style={styles.input}
              placeholder={t.auth.email}
              placeholderTextColor={Colors.light.textTertiary}
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
              autoCorrect={false}
              testID="signup-email"
            />
          </View>

          <View style={styles.inputContainer}>
            <Feather name="lock" size={18} color={Colors.light.textTertiary} style={styles.inputIcon} />
            <TextInput
              style={[styles.input, { flex: 1 }]}
              placeholder={t.auth.password}
              placeholderTextColor={Colors.light.textTertiary}
              value={password}
              onChangeText={setPassword}
              secureTextEntry={!showPassword}
              autoCapitalize="none"
              testID="signup-password"
            />
            <Pressable onPress={() => setShowPassword(!showPassword)} style={styles.eyeButton}>
              <Feather name={showPassword ? "eye-off" : "eye"} size={18} color={Colors.light.textTertiary} />
            </Pressable>
          </View>

          <View style={styles.inputContainer}>
            <Feather name="shield" size={18} color={Colors.light.textTertiary} style={styles.inputIcon} />
            <TextInput
              style={styles.input}
              placeholder="Confirm password"
              placeholderTextColor={Colors.light.textTertiary}
              value={confirmPassword}
              onChangeText={setConfirmPassword}
              secureTextEntry={!showPassword}
              autoCapitalize="none"
              testID="signup-confirm"
            />
          </View>

          <View style={styles.passwordRules}>
            <View style={styles.ruleRow}>
              <Feather name={isUsernameValid ? "check-circle" : "circle"} size={14} color={isUsernameValid ? Colors.light.success : Colors.light.textTertiary} />
              <Text style={[styles.ruleText, isUsernameValid && { color: Colors.light.success }]}>{language === "pt" ? "Nome de usuário válido (3+ caracteres)" : "Valid username (3+ characters)"}</Text>
            </View>
            <View style={styles.ruleRow}>
              <Feather name={password.length >= 6 ? "check-circle" : "circle"} size={14} color={password.length >= 6 ? Colors.light.success : Colors.light.textTertiary} />
              <Text style={[styles.ruleText, password.length >= 6 && { color: Colors.light.success }]}>{language === "pt" ? "Pelo menos 6 caracteres" : "At least 6 characters"}</Text>
            </View>
            <View style={styles.ruleRow}>
              <Feather name={password === confirmPassword && password.length > 0 ? "check-circle" : "circle"} size={14} color={password === confirmPassword && password.length > 0 ? Colors.light.success : Colors.light.textTertiary} />
              <Text style={[styles.ruleText, password === confirmPassword && password.length > 0 && { color: Colors.light.success }]}>{language === "pt" ? "Senhas coincidem" : "Passwords match"}</Text>
            </View>
          </View>

          <Pressable
            style={({ pressed }) => [styles.loginButton, pressed && { opacity: 0.85 }, loading && { opacity: 0.6 }]}
            onPress={handleSignup}
            disabled={loading || !username.trim() || !email.trim() || !password.trim() || !confirmPassword.trim()}
            testID="signup-submit"
          >
            {loading ? (
              <ActivityIndicator color="#fff" size="small" />
            ) : (
              <Text style={styles.loginButtonText}>{t.auth.signup}</Text>
            )}
          </Pressable>

          <View style={styles.signupRow}>
            <Text style={styles.signupLabel}>{t.auth.haveAccount}</Text>
            <Pressable onPress={() => router.replace("/(auth)/login")} testID="go-to-login">
              <Text style={styles.signupLink}>{t.auth.login}</Text>
            </Pressable>
          </View>
        </Animated.View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 28,
  },
  backBtn: {
    width: 40,
    height: 40,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 12,
  },
  brandContainer: {
    alignItems: "center",
    marginBottom: 28,
  },
  brandIcon: {
    width: 56,
    height: 56,
    borderRadius: 18,
    backgroundColor: Colors.light.primary,
    alignItems: "center",
    justifyContent: "center",
  },
  title: {
    fontFamily: "Rubik_700Bold",
    fontSize: 24,
    color: Colors.light.text,
    marginBottom: 6,
  },
  subtitle: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
    marginBottom: 28,
  },
  errorBox: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    backgroundColor: "#FDECEA",
    borderRadius: 12,
    padding: 14,
    marginBottom: 16,
  },
  errorText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.error,
    flex: 1,
  },
  inputContainer: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: Colors.light.surface,
    borderWidth: 1.5,
    borderColor: Colors.light.border,
    borderRadius: 14,
    paddingHorizontal: 16,
    marginBottom: 14,
  },
  inputIcon: {
    marginRight: 12,
  },
  input: {
    flex: 1,
    fontFamily: "Rubik_400Regular",
    fontSize: 15,
    color: Colors.light.text,
    paddingVertical: 16,
  },
  eyeButton: {
    padding: 8,
    marginLeft: 4,
  },
  passwordRules: {
    gap: 8,
    marginBottom: 24,
  },
  ruleRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  ruleText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
  },
  loginButton: {
    backgroundColor: Colors.light.primary,
    borderRadius: 14,
    paddingVertical: 16,
    alignItems: "center",
    marginBottom: 24,
  },
  loginButtonText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 16,
    color: "#fff",
  },
  signupRow: {
    flexDirection: "row",
    justifyContent: "center",
    gap: 6,
  },
  signupLabel: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
  },
  signupLink: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 14,
    color: Colors.light.primary,
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\(auth)\_layout.tsx ===
import { Stack, Redirect } from "expo-router";
import { useAuth } from "@/lib/auth-context";

export default function AuthLayout() {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) return null;
  if (isAuthenticated) return <Redirect href="/(tabs)" />;

  return (
    <Stack screenOptions={{ headerShown: false, animation: "slide_from_right" }}>
      <Stack.Screen name="login" />
      <Stack.Screen name="signup" />
      <Stack.Screen name="forgot-password" />
    </Stack>
  );
}

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\(tabs)\index.tsx ===
import React, { useState, useEffect } from "react";
import { StyleSheet, Text, View, Pressable, Platform, Modal } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { router } from "expo-router";
import { Feather } from "@expo/vector-icons";
import * as Haptics from "expo-haptics";
import Animated, { useAnimatedStyle, useSharedValue, withSpring, withSequence, withTiming } from "react-native-reanimated";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Colors from "@/constants/colors";
import { useRigor } from "@/lib/rigor-context";
import { useI18n } from "@/lib/i18n";

const LAST_CHECK_KEY = "@rigor_last_failure_check";

export default function TodayScreen() {
  const insets = useSafeAreaInsets();
  const { contract, markDone, getDayNumber, getCompletedCount, getFailedCount, getCurrentStreak, getDaysRemaining, getCurrentDeadline, isTodayCompleted, dayRecords, refreshData } = useRigor();
  const { t, language } = useI18n();
  const [currentTime, setCurrentTime] = useState(new Date());
  const buttonScale = useSharedValue(1);
  const [showFailureModal, setShowFailureModal] = useState(false);

  useEffect(() => {
    const timer = setInterval(() => setCurrentTime(new Date()), 1000);
    return () => clearInterval(timer);
  }, []);

  useEffect(() => {
    if (!contract) return;
    checkFailure();
  }, [contract, dayRecords, currentTime]);

  // Save / sync progress when contract loop ends (0 days remaining)
  useEffect(() => {
    if (!contract) return;
    if (getDaysRemaining() === 0) refreshData();
  }, [contract, dayRecords]);

  const checkFailure = async () => {
    if (!contract) return;
    if (showFailureModal) return;

    const now = new Date();
    const todayStr = now.toISOString().split("T")[0];

    const lastCheck = await AsyncStorage.getItem(LAST_CHECK_KEY);
    if (lastCheck === todayStr) return;

    const contractStart = contract.start_date;
    if (todayStr < contractStart) return;

    const todayRecord = dayRecords.find((r) => r.date === todayStr);
    const dl = getCurrentDeadline();
    const deadlineMinutes = dl.hour * 60 + dl.minute;
    const nowMinutes = now.getHours() * 60 + now.getMinutes();
    const isAfterDeadline = nowMinutes >= deadlineMinutes;

    // Trigger failure modal only after today's deadline has passed
    if (!isAfterDeadline) return;

    if (todayRecord) return;

    // After deadline: today not done -> show "new day" modal; or yesterday not done -> show modal
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = yesterday.toISOString().split("T")[0];
    if (yesterdayStr >= contractStart) {
      const yesterdayRecord = dayRecords.find((r) => r.date === yesterdayStr);
      if (!yesterdayRecord) {
        setShowFailureModal(true);
        return;
      }
    }
    setShowFailureModal(true);
  };

  const handleFailureResponse = async (completed: boolean) => {
    const todayStr = new Date().toISOString().split("T")[0];
    await AsyncStorage.setItem(LAST_CHECK_KEY, todayStr);
    setShowFailureModal(false);
    if (Platform.OS !== "web") {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    }
  };

  const dayNumber = getDayNumber();
  const completed = getCompletedCount();
  const failed = getFailedCount();
  const streak = getCurrentStreak();
  const remaining = getDaysRemaining();
  const deadline = getCurrentDeadline();
  const todayDone = isTodayCompleted();
  const total = contract ? contract.duration : 1;
  const progress = total > 0 ? (completed / total) : 0;

  const locale = language === 'pt' ? 'pt-BR' : 'en-US';
  const dayName = currentTime.toLocaleDateString(locale, { weekday: 'long' });
  const dayOfMonth = currentTime.getDate();
  const hours = currentTime.getHours().toString().padStart(2, '0');
  const minutes = currentTime.getMinutes().toString().padStart(2, '0');
  const deadlineStr = `${deadline.hour.toString().padStart(2, '0')}:${deadline.minute.toString().padStart(2, '0')}`;
  const ruleText = contract?.rule ?? '';

  const buttonAnimStyle = useAnimatedStyle(() => ({
    transform: [{ scale: buttonScale.value }],
  }));

  const handleDone = async () => {
    if (todayDone) return;
    buttonScale.value = withSequence(
      withSpring(0.93, { damping: 10 }),
      withSpring(1, { damping: 8 })
    );
    if (Platform.OS !== 'web') {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }
    await markDone();
  };

  if (!contract) {
    return (
      <View style={[styles.container, { paddingTop: Platform.OS === 'web' ? 67 : insets.top }]}>
        <View style={styles.header}>
          <Text style={styles.logo}>RIGOR</Text>
        </View>
        <View style={styles.emptyContainer}>
          <Feather name="target" size={48} color={Colors.light.textTertiary} />
          <Text style={styles.emptyTitle}>{t.today.noContract}</Text>
          <Text style={styles.emptyText}>{t.today.noContractDesc}</Text>
          <Pressable
            style={({ pressed }) => [styles.signButton, pressed && { opacity: 0.85, transform: [{ scale: 0.97 }] }]}
            onPress={() => router.push('/create-contract')}
          >
            <Text style={styles.signButtonText}>{t.today.signFirst}</Text>
          </Pressable>
        </View>
      </View>
    );
  }

  return (
    <main role="main" aria-label="Rigor Today" style={{ flex: 1, background: Colors.light.background, minHeight: '100vh', paddingTop: Platform.OS === 'web' ? 67 : insets.top }}>
      <header style={{ display: 'flex', flexDirection: 'row', alignItems: 'center', padding: '24px 32px', justifyContent: 'space-between', background: Colors.light.surface, borderBottom: `1px solid ${Colors.light.border}` }}>
        <div style={{ display: 'flex', alignItems: 'center' }}>
          <img src="/assets/images/logo.png" alt="RIGOR Logo" style={{ height: 40, marginRight: 16 }} />
          <span style={{ fontFamily: 'Rubik_800ExtraBold', fontSize: 28, color: Colors.light.primary, letterSpacing: 2 }}>RIGOR</span>
        </div>
        <span style={{ fontFamily: 'Rubik_700Bold', fontSize: 16, color: Colors.light.textSecondary }}>{t.today.day} {dayNumber}</span>
        <button aria-label="Share Card" style={{ background: 'none', border: 'none', cursor: 'pointer', padding: 8 }} onClick={() => router.push('/share-card')}>
          <Feather name="download" size={24} color={Colors.light.text} />
        </button>
      </header>

      <section style={{ maxWidth: 600, margin: '40px auto', background: Colors.light.surface, borderRadius: 24, boxShadow: Colors.light.cardShadow, padding: 40, display: 'flex', flexDirection: 'column', gap: 24 }}>
        <div style={{ display: 'flex', flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
          <span style={{ fontFamily: 'Rubik_400Regular', fontSize: 18, color: Colors.light.textSecondary }}>{dayOfMonth} {dayName}</span>
          <span style={{ fontFamily: 'Rubik_700Bold', fontSize: 48, color: Colors.light.text, letterSpacing: -2 }}>{hours}:{minutes}</span>
        </div>

        <div style={{ display: 'flex', flexDirection: 'row', gap: 48, justifyContent: 'center' }}>
          <div style={{ textAlign: 'center' }}>
            <span style={{ fontFamily: 'Rubik_700Bold', fontSize: 28, color: Colors.light.text }}>{completed}</span>
            <div style={{ fontFamily: 'Rubik_500Medium', fontSize: 12, color: Colors.light.textTertiary }}>{t.today.completed}</div>
          </div>
          <div style={{ textAlign: 'center' }}>
            <span style={{ fontFamily: 'Rubik_700Bold', fontSize: 28, color: Colors.light.text }}>{failed}</span>
            <div style={{ fontFamily: 'Rubik_500Medium', fontSize: 12, color: Colors.light.textTertiary }}>{t.today.failed}</div>
          </div>
        </div>

        <div aria-label="Progress Bar" style={{ height: 10, background: Colors.light.progressBg, borderRadius: 5, overflow: 'hidden', marginBottom: 16 }}>
          <div style={{ height: '100%', background: Colors.light.progressFill, width: `${Math.min(progress * 100, 100)}%`, borderRadius: 5 }} />
        </div>

        <hr style={{ border: 'none', borderTop: `1px solid ${Colors.light.borderLight}`, margin: '24px 0' }} />

        <div style={{ fontFamily: 'Rubik_400Regular', fontSize: 18, color: Colors.light.text, marginBottom: 12 }}>{contract.rule} {t.today.before} {deadlineStr}</div>

        <div style={{ display: 'flex', flexDirection: 'row', gap: 24, alignItems: 'center', justifyContent: 'center' }}>
          <span style={{ fontFamily: 'Rubik_400Regular', fontSize: 16, color: Colors.light.textTertiary }}>{remaining}d {t.today.remaining}</span>
          <span style={{ fontFamily: 'Rubik_400Regular', fontSize: 16, color: Colors.light.textTertiary }}>{t.today.streak}: {streak}</span>
          <span style={{ fontFamily: 'Rubik_600SemiBold', fontSize: 16, color: Colors.light.primary }}>{t.today.noReturn}</span>
        </div>

        {todayDone ? (
          <div style={{ fontFamily: 'Rubik_400Regular', fontSize: 18, color: Colors.light.textTertiary, textAlign: 'center', marginTop: 32 }}>{t.today.dayCompleted}</div>
        ) : (
          <Animated.View style={buttonAnimStyle}>
            <button aria-label="Mark as Done" style={{ background: Colors.light.primary, color: '#fff', fontFamily: 'Rubik_700Bold', fontSize: 20, borderRadius: 16, padding: '18px 0', margin: '24px 0', width: '100%', border: 'none', cursor: 'pointer', transition: 'opacity 0.2s' }} onClick={handleDone}>
              {t.today.done}
            </button>
          </Animated.View>
        )}
      </section>

      <Modal visible={showFailureModal} animationType="fade" transparent>
        <div role="dialog" aria-modal="true" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', background: 'rgba(0,0,0,0.5)', position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', zIndex: 1000 }}>
          <div style={{ background: Colors.light.surface, borderRadius: 24, padding: 40, width: 400, maxWidth: '90vw', alignItems: 'center', border: `3px solid ${Colors.light.primary}` }}>
            <span style={{ fontFamily: 'Rubik_800ExtraBold', fontSize: 28, color: Colors.light.primary, letterSpacing: 2, marginBottom: 20 }}>RIGOR</span>
            <div style={{ fontFamily: 'Rubik_700Bold', fontSize: 24, color: Colors.light.text, marginBottom: 8 }}>{(t.today as any).newDay}</div>
            <div style={{ fontFamily: 'Rubik_400Regular', fontSize: 16, color: Colors.light.textSecondary, textAlign: 'center', marginBottom: 24, lineHeight: 22 }}>{(t.today as any).newDayQuestion}</div>
            <button aria-label="Yes, Completed" style={{ background: Colors.light.primary, color: '#fff', fontFamily: 'Rubik_700Bold', fontSize: 18, borderRadius: 14, padding: '18px 0', width: '100%', border: 'none', marginBottom: 12, cursor: 'pointer' }} onClick={() => handleFailureResponse(true)}>{(t.today as any).yesCompleted}</button>
            <button aria-label="No, Failed" style={{ background: Colors.light.surface, color: Colors.light.text, fontFamily: 'Rubik_600SemiBold', fontSize: 16, borderRadius: 14, padding: '18px 0', width: '100%', border: `1.5px solid ${Colors.light.border}`, marginBottom: 16, cursor: 'pointer' }} onClick={() => handleFailureResponse(false)}>{(t.today as any).noFailed}</button>
            <div style={{ fontFamily: 'Rubik_400Regular', fontSize: 14, color: Colors.light.textTertiary, textAlign: 'center' }}>{(t.today as any).beHonest}</div>
          </div>
        </div>
      </Modal>
    </main>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 20,
    paddingVertical: 14,
  },
  logo: {
    fontFamily: "Rubik_800ExtraBold",
    fontSize: 18,
    color: Colors.light.text,
    letterSpacing: 1,
  },
  dayBadge: {
    backgroundColor: Colors.light.primary,
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 6,
    marginLeft: "auto",
    marginRight: 12,
  },
  dayBadgeText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 13,
    color: "#fff",
    letterSpacing: 0.5,
  },
  headerIcon: {
    padding: 4,
  },
  card: {
    backgroundColor: Colors.light.surface,
    borderRadius: 16,
    marginHorizontal: 20,
    marginTop: 8,
    padding: 24,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.04,
    shadowRadius: 8,
    elevation: 2,
  },
  dateLabel: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textSecondary,
    marginBottom: 4,
  },
  clock: {
    fontFamily: "Rubik_700Bold",
    fontSize: 56,
    color: Colors.light.text,
    letterSpacing: -2,
    marginBottom: 16,
  },
  statsRow: {
    flexDirection: "row",
    gap: 32,
    marginBottom: 16,
  },
  statItem: {
    alignItems: "center",
  },
  statNumber: {
    fontFamily: "Rubik_700Bold",
    fontSize: 22,
    color: Colors.light.text,
  },
  statLabel: {
    fontFamily: "Rubik_500Medium",
    fontSize: 10,
    color: Colors.light.textTertiary,
    letterSpacing: 0.5,
    marginTop: 2,
  },
  progressBarContainer: {
    height: 6,
    backgroundColor: Colors.light.progressBg,
    borderRadius: 3,
    marginBottom: 16,
    overflow: "hidden",
  },
  progressBarFill: {
    height: "100%",
    backgroundColor: Colors.light.progressFill,
    borderRadius: 3,
  },
  divider: {
    height: 1,
    backgroundColor: Colors.light.borderLight,
    marginBottom: 14,
  },
  ruleText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.text,
    marginBottom: 12,
  },
  metaRow: {
    flexDirection: "row",
    gap: 16,
    alignItems: "center",
  },
  metaText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textTertiary,
  },
  noReturn: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 12,
    color: Colors.light.primary,
  },
  dayCompleted: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
    textAlign: "center",
    marginTop: 32,
  },
  doneButton: {
    backgroundColor: Colors.light.primary,
    marginHorizontal: 20,
    marginTop: 24,
    borderRadius: 16,
    paddingVertical: 18,
    alignItems: "center",
  },
  doneButtonText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 18,
    color: "#fff",
  },
  emptyContainer: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 40,
    gap: 12,
  },
  emptyTitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 20,
    color: Colors.light.text,
    marginTop: 8,
  },
  emptyText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
    textAlign: "center",
  },
  signButton: {
    backgroundColor: Colors.light.primary,
    borderRadius: 16,
    paddingHorizontal: 32,
    paddingVertical: 16,
    marginTop: 16,
  },
  signButtonText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 16,
    color: "#fff",
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 28,
  },
  failureModal: {
    backgroundColor: Colors.light.surface,
    borderRadius: 24,
    padding: 32,
    width: "100%",
    alignItems: "center",
    borderWidth: 3,
    borderColor: Colors.light.primary,
  },
  failureLogo: {
    fontFamily: "Rubik_800ExtraBold",
    fontSize: 22,
    color: Colors.light.primary,
    letterSpacing: 2,
    marginBottom: 20,
  },
  failureTitle: {
    fontFamily: "Rubik_700Bold",
    fontSize: 24,
    color: Colors.light.text,
    marginBottom: 8,
  },
  failureQuestion: {
    fontFamily: "Rubik_400Regular",
    fontSize: 15,
    color: Colors.light.textSecondary,
    textAlign: "center",
    marginBottom: 24,
    lineHeight: 22,
  },
  failureYesButton: {
    backgroundColor: Colors.light.primary,
    width: "100%",
    borderRadius: 14,
    paddingVertical: 18,
    alignItems: "center",
    marginBottom: 12,
  },
  failureYesText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 17,
    color: "#fff",
  },
  failureNoButton: {
    backgroundColor: Colors.light.surface,
    width: "100%",
    borderRadius: 14,
    paddingVertical: 18,
    alignItems: "center",
    borderWidth: 1.5,
    borderColor: Colors.light.border,
    marginBottom: 16,
  },
  failureNoText: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 16,
    color: Colors.light.text,
  },
  failureHint: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
    textAlign: "center",
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\(tabs)\profile.tsx ===
import React, { useState, useEffect } from "react";
import { StyleSheet, Text, View, ScrollView, Pressable, Alert, Platform, Switch, Modal } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { router } from "expo-router";
import { Feather, Ionicons } from "@expo/vector-icons";
import * as Notifications from "expo-notifications";
import * as Haptics from "expo-haptics";
import AsyncStorage from "@react-native-async-storage/async-storage";
import Colors from "@/constants/colors";
import { useRigor } from "@/lib/rigor-context";
import { useAuth } from "@/lib/auth-context";
import { useI18n, Language } from "@/lib/i18n";
import ProUpgradeModal from "@/components/ProUpgradeModal";

const NOTIFICATIONS_KEY = "@rigor_notifications";
const DIFFICULTY_KEY = "@rigor_difficulty";
const RESET_COUNT_KEY = "@rigor_reset_count";

export type Difficulty = "medium" | "hard" | "extreme";

const DIFFICULTY_OPTIONS: { key: Difficulty; missions: number; pro: boolean }[] = [
  { key: "medium", missions: 1, pro: false },
  { key: "hard", missions: 4, pro: true },
  { key: "extreme", missions: 6, pro: true },
];

Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: false,
  }),
});

export default function ProfileScreen() {
  const insets = useSafeAreaInsets();
  const { contract, getCompletedCount, getFailedCount, getCurrentStreak, getBestStreak, getCompletionRate, getDaysRemaining, resetAll, resetProgress } = useRigor();
  const { user, logout } = useAuth();
  const { language, setLanguage, t } = useI18n();
  const [notificationsEnabled, setNotificationsEnabled] = useState(false);
  const [showLanguage, setShowLanguage] = useState(false);
  const [showDifficulty, setShowDifficulty] = useState(false);
  const [difficulty, setDifficultyState] = useState<Difficulty>("medium");
  const [resetCount, setResetCount] = useState(0);
  const [showProModal, setShowProModal] = useState(false);
  const isPro = false;

  const completed = getCompletedCount();
  const failed = getFailedCount();
  const currentStreak = getCurrentStreak();
  const bestStreak = getBestStreak();
  const rate = getCompletionRate();
  const remaining = getDaysRemaining();

  useEffect(() => {
    loadNotificationState();
    loadDifficulty();
    loadResetCount();
  }, []);

  const loadNotificationState = async () => {
    try {
      const val = await AsyncStorage.getItem(NOTIFICATIONS_KEY);
      setNotificationsEnabled(val === "true");
    } catch {}
  };

  const loadResetCount = async () => {
    try {
      const val = await AsyncStorage.getItem(RESET_COUNT_KEY);
      if (val) setResetCount(parseInt(val, 10));
    } catch {}
  };

  const loadDifficulty = async () => {
    try {
      const val = await AsyncStorage.getItem(DIFFICULTY_KEY);
      if (val === "medium" || val === "hard" || val === "extreme") {
        setDifficultyState(val);
      }
    } catch {}
  };

  const handleSetDifficulty = async (d: Difficulty) => {
    if (d !== "medium" && DIFFICULTY_OPTIONS.find(o => o.key === d)?.pro && !isPro) {
      setShowDifficulty(false);
      setShowProModal(true);
      return;
    }
    setDifficultyState(d);
    await AsyncStorage.setItem(DIFFICULTY_KEY, d);
    if (Platform.OS !== "web") Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setShowDifficulty(false);
  };

  const handleSetLanguage = async (lang: Language) => {
    await setLanguage(lang);
    if (Platform.OS !== "web") Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setShowLanguage(false);
  };

  const toggleNotifications = async (value: boolean) => {
    if (value) {
      const { status: existingStatus } = await Notifications.getPermissionsAsync();
      let finalStatus = existingStatus;
      if (existingStatus !== "granted") {
        const { status } = await Notifications.requestPermissionsAsync();
        finalStatus = status;
      }
      if (finalStatus !== "granted") {
        if (Platform.OS === "web") {
          window.alert([t.profile.permissionNeeded, t.profile.permissionMessage].filter(Boolean).join("\n"));
        } else {
          Alert.alert(t.profile.permissionNeeded, t.profile.permissionMessage);
        }
        return;
      }

      await Notifications.cancelAllScheduledNotificationsAsync();
      await Notifications.scheduleNotificationAsync({
        content: {
          title: "RIGOR",
          body: language === "pt" ? "Hora de cumprir sua missão diária. Sem desculpas." : "Time to complete your daily task. No excuses.",
          sound: true,
        },
        trigger: {
          type: Notifications.SchedulableTriggerInputTypes.DAILY,
          hour: 9,
          minute: 0,
        },
      });

      setNotificationsEnabled(true);
      await AsyncStorage.setItem(NOTIFICATIONS_KEY, "true");
    } else {
      await Notifications.cancelAllScheduledNotificationsAsync();
      setNotificationsEnabled(false);
      await AsyncStorage.setItem(NOTIFICATIONS_KEY, "false");
    }
  };

  const canResetProgress = isPro || resetCount < 1;

  const runResetProgress = async () => {
    const success = await resetProgress();
    if (success && !isPro) {
      const newCount = resetCount + 1;
      setResetCount(newCount);
      await AsyncStorage.setItem(RESET_COUNT_KEY, newCount.toString());
    }
    if (success && Platform.OS !== "web") {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }
  };

  const handleResetProgress = () => {
    if (typeof __DEV__ !== "undefined" && __DEV__) console.log("[Profile] Reset progress button pressed");
    if (!canResetProgress) {
      setShowProModal(true);
      return;
    }
    if (Platform.OS === "web") {
      if (window.confirm((t.profile as any).resetProgressMessage || "Reset progress?")) {
        runResetProgress();
      }
      return;
    }
    Alert.alert(
      (t.profile as any).resetProgressTitle,
      (t.profile as any).resetProgressMessage,
      [
        { text: t.profile.cancel, style: "cancel" },
        { text: (t.profile as any).resetProgressConfirm, style: "destructive", onPress: runResetProgress },
      ]
    );
  };

  const handleReset = () => {
    if (typeof __DEV__ !== "undefined" && __DEV__) console.log("[Profile] Reset all button pressed");
    if (Platform.OS === "web") {
      if (window.confirm(t.profile.resetMessage || "Delete all data?")) {
        resetAll();
      }
      return;
    }
    Alert.alert(
      t.profile.resetTitle,
      t.profile.resetMessage,
      [
        { text: t.profile.cancel, style: "cancel" },
        { text: t.profile.reset, style: "destructive", onPress: () => { console.log("[Profile] Reset confirmed"); resetAll(); } },
      ]
    );
  };

  const handleLogout = () => {
    if (typeof __DEV__ !== "undefined" && __DEV__) console.log("[Profile] Sign out button pressed");
    if (Platform.OS === "web") {
      if (window.confirm(t.profile.signOutConfirm || "Sign out?")) {
        logout();
      }
      return;
    }
    Alert.alert(
      t.profile.signOut,
      t.profile.signOutConfirm,
      [
        { text: t.profile.cancel, style: "cancel" },
        { text: t.profile.signOut, style: "destructive", onPress: () => { console.log("[Profile] Logout confirmed"); logout(); } },
      ]
    );
  };

  const currentDiffOption = DIFFICULTY_OPTIONS.find(o => o.key === difficulty)!;
  const difficultyLabel = t.profile[difficulty as keyof typeof t.profile] as string;
  const languageLabel = language === "en" ? t.profile.english : t.profile.portuguese;

  return (
    <>
    <ScrollView
      style={styles.container}
      contentContainerStyle={{ paddingTop: Platform.OS === 'web' ? 67 : insets.top + 16, paddingBottom: 120 }}
    >
      <Text style={styles.title}>{t.profile.title}</Text>

      <View style={styles.userCard}>
        <View style={styles.avatarContainer}>
          <View style={styles.avatar}>
            <Feather name="user" size={22} color={Colors.light.primary} />
          </View>
          <View style={styles.userInfo}>
            <Text style={styles.userName} numberOfLines={1}>
              {user?.username || (user?.email ? user.email.split("@")[0] : "") || "User"}
            </Text>
            <Text style={styles.userEmail} numberOfLines={1}>{user?.email ?? ""}</Text>
          </View>
        </View>
      </View>

      {contract && (
        <View style={styles.contractCard}>
          <View style={styles.contractHeader}>
            <View style={styles.contractBadge}>
              <Feather name="file-text" size={16} color={Colors.light.primary} />
            </View>
            <Text style={styles.contractTitle}>{t.profile.activeContract}</Text>
          </View>
          <View style={styles.contractDetail}>
            <Text style={styles.contractLabel}>{t.profile.rule}</Text>
            <Text style={styles.contractValue}>{contract.rule}</Text>
          </View>
          <View style={styles.contractDetail}>
            <Text style={styles.contractLabel}>{t.profile.duration}</Text>
            <Text style={styles.contractValue}>{contract.duration} {t.profile.days}</Text>
          </View>
          <View style={styles.contractDetail}>
            <Text style={styles.contractLabel}>{t.profile.deadline}</Text>
            <Text style={styles.contractValue}>
              {contract.deadline_hour.toString().padStart(2, '0')}:{contract.deadline_minute.toString().padStart(2, '0')}
            </Text>
          </View>
          <View style={styles.contractDetail}>
            <Text style={styles.contractLabel}>{t.profile.startDate}</Text>
            <Text style={styles.contractValue}>{contract.start_date}</Text>
          </View>
          <View style={[styles.contractDetail, { borderBottomWidth: 0 }]}>
            <Text style={styles.contractLabel}>{t.profile.remaining}</Text>
            <Text style={styles.contractValue}>{remaining} {t.profile.days}</Text>
          </View>
        </View>
      )}

      <Text style={styles.sectionTitle}>{t.profile.statistics}</Text>

      <View style={styles.statsGrid}>
        <View style={styles.statsItem}>
          <Ionicons name="checkmark-circle" size={20} color={Colors.light.success} />
          <Text style={styles.statsValue}>{completed}</Text>
          <Text style={styles.statsLabel}>{t.profile.completed}</Text>
        </View>
        <View style={styles.statsItem}>
          <Ionicons name="close-circle" size={20} color={Colors.light.error} />
          <Text style={styles.statsValue}>{failed}</Text>
          <Text style={styles.statsLabel}>{t.profile.failed}</Text>
        </View>
        <View style={styles.statsItem}>
          <Ionicons name="trending-up" size={20} color={Colors.light.primary} />
          <Text style={styles.statsValue}>{rate}%</Text>
          <Text style={styles.statsLabel}>{t.profile.rate}</Text>
        </View>
        <View style={styles.statsItem}>
          <Ionicons name="flame" size={20} color={Colors.light.primary} />
          <Text style={styles.statsValue}>{currentStreak}</Text>
          <Text style={styles.statsLabel}>{t.profile.streak}</Text>
        </View>
      </View>

      <View style={styles.insightRow}>
        <View style={[styles.insightIcon, { backgroundColor: '#FFF3E0' }]}>
          <Ionicons name="flame" size={18} color={Colors.light.primary} />
        </View>
        <Text style={styles.insightLabel}>{t.profile.bestStreak}</Text>
        <Text style={styles.insightValue}>{bestStreak} {bestStreak === 1 ? t.profile.day : t.profile.days}</Text>
      </View>

      <Text style={styles.sectionTitle}>{t.profile.settings}</Text>

      <View style={styles.settingRow}>
        <Feather name="bell" size={18} color={Colors.light.text} />
        <Text style={styles.settingText}>{t.profile.dailyReminder}</Text>
        <Switch
          value={notificationsEnabled}
          onValueChange={toggleNotifications}
          trackColor={{ false: Colors.light.border, true: Colors.light.primary }}
          thumbColor="#fff"
          testID="notification-toggle"
        />
      </View>

      <Pressable
        style={({ pressed }) => [styles.settingRow, pressed && { opacity: 0.7 }]}
        onPress={() => setShowLanguage(true)}
        testID="language-button"
      >
        <Ionicons name="language" size={18} color={Colors.light.text} />
        <Text style={styles.settingText}>{t.profile.language}</Text>
        <Text style={styles.settingValue}>{languageLabel}</Text>
        <Feather name="chevron-right" size={16} color={Colors.light.textTertiary} />
      </Pressable>

      <Pressable
        style={({ pressed }) => [styles.settingRow, pressed && { opacity: 0.7 }]}
        onPress={() => setShowDifficulty(true)}
        testID="difficulty-button"
      >
        <Ionicons name="speedometer" size={18} color={Colors.light.text} />
        <Text style={styles.settingText}>{t.profile.difficulty}</Text>
        <Text style={styles.settingValue}>{difficultyLabel}</Text>
        <Feather name="chevron-right" size={16} color={Colors.light.textTertiary} />
      </Pressable>

      <Pressable
        style={({ pressed }) => [styles.settingRow, pressed && { opacity: 0.7 }]}
        onPress={() => router.push("/about")}
        testID="about-button"
      >
        <Feather name="info" size={18} color={Colors.light.text} />
        <Text style={styles.settingText}>{t.profile.aboutRigor}</Text>
        <Feather name="chevron-right" size={16} color={Colors.light.textTertiary} />
      </Pressable>

      <Pressable
        style={({ pressed }) => [styles.resetProgressRow, pressed && { opacity: 0.7 }, !canResetProgress && styles.resetProgressDisabled]}
        onPress={handleResetProgress}
        testID="reset-progress-button"
      >
        <View style={styles.resetProgressIcon}>
          <Ionicons name="refresh" size={20} color={canResetProgress ? Colors.light.error : Colors.light.textTertiary} />
        </View>
        <View style={{ flex: 1 }}>
          <Text style={[styles.resetProgressTitle, !canResetProgress && { color: Colors.light.textTertiary }]}>
            {(t.profile as any).resetProgress}
          </Text>
          <Text style={styles.resetProgressSub}>
            {isPro
              ? (t.profile as any).resetProgressPro
              : resetCount >= 1
                ? (t.profile as any).resetProgressUsed
                : (t.profile as any).resetProgressFree}
          </Text>
        </View>
      </Pressable>

      <Pressable
        style={({ pressed }) => [styles.logoutButton, pressed && { opacity: 0.85 }]}
        onPress={handleLogout}
        testID="logout-button"
      >
        <Feather name="log-out" size={16} color={Colors.light.primary} />
        <Text style={styles.logoutText}>{t.profile.signOut}</Text>
      </Pressable>

      <Pressable
        style={({ pressed }) => [styles.resetButton, pressed && { opacity: 0.85 }]}
        onPress={handleReset}
      >
        <Feather name="trash-2" size={16} color={Colors.light.error} />
        <Text style={styles.resetText}>{t.profile.resetAll}</Text>
      </Pressable>

      <Text style={styles.version}>RIGOR v1.0.0</Text>

      <Modal visible={showLanguage} animationType="fade" transparent>
        <Pressable style={styles.modalOverlay} onPress={() => setShowLanguage(false)}>
          <Pressable style={styles.modalContent} onPress={(e) => e.stopPropagation()}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>{t.profile.languageTitle}</Text>
              <Pressable onPress={() => setShowLanguage(false)} hitSlop={12}>
                <Feather name="x" size={20} color={Colors.light.text} />
              </Pressable>
            </View>

            <Pressable
              style={[styles.optionCard, language === "en" && styles.optionCardSelected]}
              onPress={() => handleSetLanguage("en")}
            >
              <Text style={[styles.optionLabel, language === "en" && styles.optionLabelSelected]}>English</Text>
              {language === "en" && (
                <Ionicons name="checkmark-circle" size={22} color={Colors.light.primary} />
              )}
            </Pressable>

            <Pressable
              style={[styles.optionCard, language === "pt" && styles.optionCardSelected]}
              onPress={() => handleSetLanguage("pt")}
            >
              <Text style={[styles.optionLabel, language === "pt" && styles.optionLabelSelected]}>Português</Text>
              {language === "pt" && (
                <Ionicons name="checkmark-circle" size={22} color={Colors.light.primary} />
              )}
            </Pressable>
          </Pressable>
        </Pressable>
      </Modal>

      <Modal visible={showDifficulty} animationType="fade" transparent>
        <Pressable style={styles.modalOverlay} onPress={() => setShowDifficulty(false)}>
          <Pressable style={styles.modalContent} onPress={(e) => e.stopPropagation()}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>{t.profile.difficultyTitle}</Text>
              <Pressable onPress={() => setShowDifficulty(false)} hitSlop={12}>
                <Feather name="x" size={20} color={Colors.light.text} />
              </Pressable>
            </View>

            <Text style={styles.diffWarning}>{t.profile.difficultyWarning}</Text>

            {DIFFICULTY_OPTIONS.map((option) => {
              const isSelected = difficulty === option.key;
              const label = t.profile[option.key as keyof typeof t.profile] as string;
              const missionCount = option.missions;
              const missionLabel = missionCount === 1 ? t.profile.mission : t.profile.missions;

              return (
                <Pressable
                  key={option.key}
                  style={[styles.optionCard, isSelected && styles.optionCardSelected]}
                  onPress={() => handleSetDifficulty(option.key)}
                >
                  <View>
                    <View style={styles.optionNameRow}>
                      <Text style={[styles.optionLabel, isSelected && styles.optionLabelSelected]}>{label}</Text>
                      {option.pro && (
                        <View style={styles.proBadge}>
                          <Text style={styles.proBadgeText}>{t.profile.pro}</Text>
                        </View>
                      )}
                    </View>
                    <Text style={styles.optionSub}>{missionCount} {missionLabel}</Text>
                  </View>
                  {isSelected ? (
                    <Ionicons name="checkmark-circle" size={22} color={Colors.light.primary} />
                  ) : option.pro ? (
                    <Feather name="lock" size={18} color={Colors.light.textTertiary} />
                  ) : null}
                </Pressable>
              );
            })}

            <Pressable
              style={styles.cancelButton}
              onPress={() => setShowDifficulty(false)}
            >
              <Text style={styles.cancelButtonText}>{t.profile.cancel}</Text>
            </Pressable>
          </Pressable>
        </Pressable>
      </Modal>
    </ScrollView>
    <ProUpgradeModal visible={showProModal} onClose={() => setShowProModal(false)} />
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  title: {
    fontFamily: "Rubik_700Bold",
    fontSize: 28,
    color: Colors.light.text,
    paddingHorizontal: 20,
    marginBottom: 20,
  },
  userCard: {
    backgroundColor: Colors.light.surface,
    marginHorizontal: 20,
    borderRadius: 16,
    padding: 18,
    marginBottom: 24,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  avatarContainer: {
    flexDirection: "row",
    alignItems: "center",
    gap: 14,
  },
  avatar: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: "#FFF3E0",
    alignItems: "center",
    justifyContent: "center",
  },
  userInfo: {
    flex: 1,
  },
  userName: {
    fontFamily: "Rubik_700Bold",
    fontSize: 16,
    color: Colors.light.text,
  },
  userEmail: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
    marginTop: 2,
  },
  contractCard: {
    backgroundColor: Colors.light.surface,
    marginHorizontal: 20,
    borderRadius: 16,
    padding: 20,
    marginBottom: 24,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  contractHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
    marginBottom: 16,
  },
  contractBadge: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#FFF3E0',
    alignItems: "center",
    justifyContent: "center",
  },
  contractTitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 16,
    color: Colors.light.text,
  },
  contractDetail: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.borderLight,
  },
  contractLabel: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
  },
  contractValue: {
    fontFamily: "Rubik_500Medium",
    fontSize: 14,
    color: Colors.light.text,
  },
  sectionTitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 11,
    color: Colors.light.textTertiary,
    letterSpacing: 1,
    paddingHorizontal: 20,
    marginBottom: 12,
  },
  statsGrid: {
    flexDirection: "row",
    paddingHorizontal: 20,
    gap: 10,
    marginBottom: 16,
  },
  statsItem: {
    flex: 1,
    backgroundColor: Colors.light.surface,
    borderRadius: 14,
    padding: 14,
    alignItems: "center",
    gap: 6,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  statsValue: {
    fontFamily: "Rubik_700Bold",
    fontSize: 18,
    color: Colors.light.text,
  },
  statsLabel: {
    fontFamily: "Rubik_400Regular",
    fontSize: 10,
    color: Colors.light.textTertiary,
  },
  insightRow: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: Colors.light.surface,
    marginHorizontal: 20,
    borderRadius: 14,
    padding: 16,
    marginBottom: 24,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  insightIcon: {
    width: 36,
    height: 36,
    borderRadius: 18,
    alignItems: "center",
    justifyContent: "center",
    marginRight: 12,
  },
  insightLabel: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.text,
    flex: 1,
  },
  insightValue: {
    fontFamily: "Rubik_700Bold",
    fontSize: 15,
    color: Colors.light.text,
  },
  settingRow: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: Colors.light.surface,
    marginHorizontal: 20,
    borderRadius: 14,
    padding: 16,
    marginBottom: 8,
    gap: 12,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  settingText: {
    fontFamily: "Rubik_500Medium",
    fontSize: 15,
    color: Colors.light.text,
    flex: 1,
  },
  settingValue: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
    marginRight: 4,
  },
  logoutButton: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
    marginHorizontal: 20,
    marginTop: 24,
    paddingVertical: 16,
    borderRadius: 14,
    borderWidth: 1.5,
    borderColor: Colors.light.primary,
  },
  logoutText: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 15,
    color: Colors.light.primary,
  },
  resetButton: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
    marginHorizontal: 20,
    marginTop: 12,
    paddingVertical: 16,
    borderRadius: 14,
    borderWidth: 1,
    borderColor: Colors.light.error,
  },
  resetText: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 15,
    color: Colors.light.error,
  },
  resetProgressRow: {
    flexDirection: "row" as const,
    alignItems: "center" as const,
    backgroundColor: Colors.light.surface,
    marginHorizontal: 20,
    borderRadius: 14,
    padding: 16,
    marginTop: 8,
    marginBottom: 8,
    gap: 14,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  resetProgressDisabled: {
    opacity: 0.5,
  },
  resetProgressIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: "#FFF0F0",
    alignItems: "center" as const,
    justifyContent: "center" as const,
  },
  resetProgressTitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 15,
    color: Colors.light.text,
  },
  resetProgressSub: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
    marginTop: 2,
  },
  version: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textTertiary,
    textAlign: "center" as const,
    marginTop: 24,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "flex-end",
  },
  modalContent: {
    backgroundColor: Colors.light.surface,
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    paddingHorizontal: 20,
    paddingTop: 24,
    paddingBottom: Platform.OS === "web" ? 34 : 40,
  },
  modalHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 16,
  },
  modalTitle: {
    fontFamily: "Rubik_700Bold",
    fontSize: 20,
    color: Colors.light.text,
  },
  diffWarning: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
    marginBottom: 16,
  },
  optionCard: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    backgroundColor: Colors.light.background,
    borderRadius: 14,
    padding: 18,
    marginBottom: 10,
    borderWidth: 2,
    borderColor: "transparent",
  },
  optionCardSelected: {
    borderColor: Colors.light.primary,
    backgroundColor: "#FFF3E0",
  },
  optionNameRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  optionLabel: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 16,
    color: Colors.light.text,
  },
  optionLabelSelected: {
    color: Colors.light.text,
  },
  optionSub: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
    marginTop: 2,
  },
  proBadge: {
    backgroundColor: Colors.light.primary,
    borderRadius: 6,
    paddingHorizontal: 8,
    paddingVertical: 2,
  },
  proBadgeText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 10,
    color: "#fff",
    letterSpacing: 0.5,
  },
  cancelButton: {
    backgroundColor: Colors.light.background,
    borderRadius: 14,
    paddingVertical: 16,
    alignItems: "center",
    marginTop: 6,
  },
  cancelButtonText: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 16,
    color: Colors.light.text,
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\(tabs)\progress.tsx ===
import React from "react";
import { StyleSheet, Text, View, ScrollView, Platform } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { Ionicons, Feather } from "@expo/vector-icons";
import Colors from "@/constants/colors";
import { useRigor } from "@/lib/rigor-context";
import { useI18n } from "@/lib/i18n";

function ConsistencyDot({ status }: { status: 'done' | 'fail' | 'critical' | 'empty' }) {
  const color = status === 'done' ? Colors.light.dotDone
    : status === 'fail' ? Colors.light.dotFail
    : status === 'critical' ? Colors.light.dotCritical
    : Colors.light.dot;
  return <View style={[styles.dot, { backgroundColor: color }]} />;
}

export default function ProgressScreen() {
  const insets = useSafeAreaInsets();
  const { contract, dayRecords, getCompletionRate, getCompletedCount, getFailedCount, getBestStreak, getCurrentStreak } = useRigor();
  const { t } = useI18n();

  const rate = getCompletionRate();
  const done = getCompletedCount();
  const fails = getFailedCount();
  const bestStreak = getBestStreak();
  const currentStreak = getCurrentStreak();
  const duration = contract?.duration ?? 30;

  const dots: Array<'done' | 'fail' | 'critical' | 'empty'> = [];
  if (contract) {
    for (let i = 0; i < duration; i++) {
      const d = new Date(contract.start_date + 'T00:00:00');
      d.setDate(d.getDate() + i);
      const dateStr = d.toISOString().split('T')[0];
      const record = dayRecords.find(r => r.date === dateStr);
      if (record) {
        if (record.critical) dots.push('critical');
        else if (record.failed) dots.push('fail');
        else if (record.completed) dots.push('done');
        else dots.push('empty');
      } else {
        dots.push('empty');
      }
    }
  } else {
    for (let i = 0; i < 30; i++) dots.push('empty');
  }

  return (
    <ScrollView
      style={[styles.container]}
      contentContainerStyle={{ paddingTop: Platform.OS === 'web' ? 67 : insets.top + 16, paddingBottom: 120 }}
      contentInsetAdjustmentBehavior="automatic"
    >
      <Text style={styles.title}>{t.progress.title}</Text>
      <Text style={styles.subtitle}>{contract?.rule ?? 'Workout'}</Text>

      <View style={styles.dropdownContainer}>
        <Text style={styles.dropdownText}>
          {contract?.rule ?? 'Workout'} — {duration}d {contract ? `(${t.progress.active})` : ''}
        </Text>
        <Feather name="chevron-down" size={18} color={Colors.light.textSecondary} />
      </View>

      <View style={styles.statsCards}>
        <View style={styles.statCard}>
          <Text style={[styles.statValue, { color: Colors.light.primary }]}>{rate}%</Text>
          <Text style={styles.statCardLabel}>{t.progress.rate}</Text>
        </View>
        <View style={styles.statCard}>
          <Text style={styles.statValue}>{done}</Text>
          <Text style={styles.statCardLabel}>{t.progress.done}</Text>
        </View>
        <View style={styles.statCard}>
          <Text style={styles.statValue}>{fails}</Text>
          <Text style={styles.statCardLabel}>{t.progress.fails}</Text>
        </View>
      </View>

      <View style={styles.mapCard}>
        <Text style={styles.mapTitle}>{t.progress.consistencyMap}</Text>
        <View style={styles.dotsGrid}>
          {dots.map((status, i) => (
            <ConsistencyDot key={i} status={status} />
          ))}
        </View>
        <View style={styles.legendRow}>
          <View style={styles.legendItem}>
            <View style={[styles.legendDot, { backgroundColor: Colors.light.dotDone }]} />
            <Text style={styles.legendText}>{t.progress.legendDone}</Text>
          </View>
          <View style={styles.legendItem}>
            <View style={[styles.legendDot, { backgroundColor: Colors.light.dotFail }]} />
            <Text style={styles.legendText}>{t.progress.legendFail}</Text>
          </View>
          <View style={styles.legendItem}>
            <View style={[styles.legendDot, { backgroundColor: Colors.light.dotCritical }]} />
            <Text style={styles.legendText}>{t.progress.legendCritical}</Text>
          </View>
        </View>
      </View>

      <Text style={styles.insightsTitle}>{t.progress.insights}</Text>

      <View style={styles.insightCard}>
        <View style={[styles.insightIcon, { backgroundColor: '#FFF3E0' }]}>
          <Ionicons name="flame" size={20} color={Colors.light.primary} />
        </View>
        <Text style={styles.insightLabel}>{t.progress.bestStreak}</Text>
        <Text style={styles.insightValue}>{bestStreak} {bestStreak === 1 ? t.progress.day : t.progress.days}</Text>
      </View>

      <View style={styles.insightCard}>
        <View style={[styles.insightIcon, { backgroundColor: '#FFF3E0' }]}>
          <Ionicons name="trending-up" size={20} color={Colors.light.primary} />
        </View>
        <Text style={styles.insightLabel}>{t.progress.currentStreak}</Text>
        <Text style={styles.insightValue}>{currentStreak} {currentStreak === 1 ? t.progress.day : t.progress.days}</Text>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  title: {
    fontFamily: "Rubik_700Bold",
    fontSize: 28,
    color: Colors.light.text,
    paddingHorizontal: 20,
    marginBottom: 2,
  },
  subtitle: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
    paddingHorizontal: 20,
    marginBottom: 16,
  },
  dropdownContainer: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    backgroundColor: Colors.light.surface,
    marginHorizontal: 20,
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 14,
    borderWidth: 1,
    borderColor: Colors.light.border,
    marginBottom: 20,
  },
  dropdownText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.text,
  },
  statsCards: {
    flexDirection: "row",
    paddingHorizontal: 20,
    gap: 10,
    marginBottom: 20,
  },
  statCard: {
    flex: 1,
    backgroundColor: Colors.light.surface,
    borderRadius: 14,
    paddingVertical: 18,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  statValue: {
    fontFamily: "Rubik_700Bold",
    fontSize: 26,
    color: Colors.light.text,
    marginBottom: 4,
  },
  statCardLabel: {
    fontFamily: "Rubik_500Medium",
    fontSize: 10,
    color: Colors.light.textTertiary,
    letterSpacing: 0.5,
  },
  mapCard: {
    backgroundColor: Colors.light.surface,
    marginHorizontal: 20,
    borderRadius: 16,
    padding: 20,
    marginBottom: 24,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  mapTitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 11,
    color: Colors.light.textTertiary,
    letterSpacing: 1,
    marginBottom: 16,
  },
  dotsGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 6,
    marginBottom: 16,
  },
  dot: {
    width: 18,
    height: 18,
    borderRadius: 9,
  },
  legendRow: {
    flexDirection: "row",
    gap: 20,
  },
  legendItem: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  legendDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
  },
  legendText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textTertiary,
  },
  insightsTitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 11,
    color: Colors.light.textTertiary,
    letterSpacing: 1,
    paddingHorizontal: 20,
    marginBottom: 12,
  },
  insightCard: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: Colors.light.surface,
    marginHorizontal: 20,
    borderRadius: 14,
    padding: 16,
    marginBottom: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  insightIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    alignItems: "center",
    justifyContent: "center",
    marginRight: 14,
  },
  insightLabel: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.text,
    flex: 1,
  },
  insightValue: {
    fontFamily: "Rubik_700Bold",
    fontSize: 16,
    color: Colors.light.text,
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\(tabs)\squads.tsx ===
import React, { useState, useCallback } from "react";
import { StyleSheet, Text, View, ScrollView, Pressable, TextInput, Modal, Alert, Platform, ActivityIndicator } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { Ionicons, Feather, MaterialCommunityIcons } from "@expo/vector-icons";
import * as Haptics from "expo-haptics";
import * as Clipboard from "expo-clipboard";
import Colors from "@/constants/colors";
import { useRigor, Squad } from "@/lib/rigor-context";
import { useI18n } from "@/lib/i18n";
import { getApiUrl } from "@/lib/query-client";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { fetch } from "expo/fetch";

const AUTH_TOKEN_KEY = "@rigor_auth_token";

interface SquadMember {
  user_id: string;
  display_name: string;
  is_me: boolean;
  completed_days: number;
  failed_days: number;
  joined_at: string;
}

export default function SquadsScreen() {
  const insets = useSafeAreaInsets();
  const { squads, createSquad, joinSquad, leaveSquad } = useRigor();
  const { t, language } = useI18n();
  const [showCreate, setShowCreate] = useState(false);
  const [showJoin, setShowJoin] = useState(false);
  const [squadName, setSquadName] = useState("");
  const [joinCode, setJoinCode] = useState("");
  const [selectedSquad, setSelectedSquad] = useState<Squad | null>(null);
  const [members, setMembers] = useState<SquadMember[]>([]);
  const [loadingMembers, setLoadingMembers] = useState(false);
  const [codeCopied, setCodeCopied] = useState(false);

  const loadMembers = useCallback(async (squadId: string) => {
    setLoadingMembers(true);
    try {
      const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);
      const baseUrl = getApiUrl();
      const res = await fetch(new URL(`/api/squads/${squadId}/members`, baseUrl).toString(), {
        headers: token ? { Authorization: `Bearer ${token}` } : {},
      });
      if (res.ok) {
        const data = await res.json();
        setMembers(data.members || []);
      }
    } catch (e) {
      console.error("Failed to load members:", e);
    } finally {
      setLoadingMembers(false);
    }
  }, []);

  const openSquadDetail = useCallback((squad: Squad) => {
    setSelectedSquad(squad);
    setCodeCopied(false);
    loadMembers(squad.id);
  }, [loadMembers]);

  const handleCreate = async () => {
    if (!squadName.trim()) return;
    await createSquad(squadName.trim());
    if (Platform.OS !== "web") Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    setSquadName("");
    setShowCreate(false);
  };

  const handleJoin = async () => {
    if (!joinCode.trim()) return;
    const success = await joinSquad(joinCode.trim().toLowerCase());
    if (success) {
      if (Platform.OS !== "web") Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      setJoinCode("");
      setShowJoin(false);
    } else {
      Alert.alert("Error", t.squads.errorInvalidCode);
    }
  };

  const handleLeave = (id: string, name: string) => {
    const msg = t.squads.leaveMessage.replace("{name}", name);
    Alert.alert(t.squads.leaveTitle, msg, [
      { text: t.squads.cancel, style: "cancel" },
      {
        text: t.squads.leave,
        style: "destructive",
        onPress: async () => {
          await leaveSquad(id);
          setSelectedSquad(null);
          setMembers([]);
        },
      },
    ]);
  };

  const handleCopyCode = async (code: string) => {
    try {
      await Clipboard.setStringAsync(code);
      setCodeCopied(true);
      if (Platform.OS !== "web") Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      setTimeout(() => setCodeCopied(false), 2000);
    } catch {}
  };

  const formatJoinDate = (dateStr: string) => {
    try {
      const d = new Date(dateStr);
      const day = d.getDate();
      const locale = language === 'pt' ? 'pt-BR' : 'en-US';
      const month = d.toLocaleDateString(locale, { month: 'short' });
      return `${day} ${month}`;
    } catch {
      return "";
    }
  };

  if (selectedSquad) {
    return (
      <ScrollView
        style={styles.container}
        contentContainerStyle={{ paddingTop: Platform.OS === "web" ? 67 : insets.top + 16, paddingBottom: Platform.OS === "web" ? 34 : 120 }}
      >
        <View style={styles.detailHeader}>
          <Text style={styles.detailTitle}>{selectedSquad.name}</Text>
          <Pressable onPress={() => { setSelectedSquad(null); setMembers([]); }} hitSlop={12}>
            <Text style={styles.backText}>{t.squads.back}</Text>
          </Pressable>
        </View>

        <View style={styles.codeCard}>
          <Text style={styles.codeLabel}>{t.squads.codeLabel}</Text>
          <View style={styles.codeRow}>
            <Text style={styles.codeValue}>{selectedSquad.code}</Text>
            <Pressable onPress={() => handleCopyCode(selectedSquad.code)} hitSlop={12}>
              <Feather name={codeCopied ? "check" : "copy"} size={20} color={codeCopied ? Colors.light.success : Colors.light.textTertiary} />
            </Pressable>
          </View>
        </View>

        <Text style={styles.sectionLabel}>{t.squads.ranking}</Text>

        {loadingMembers ? (
          <ActivityIndicator size="small" color={Colors.light.primary} style={{ marginTop: 20 }} />
        ) : members.length === 0 ? (
          <Text style={styles.noMembers}>{t.squads.noMembers}</Text>
        ) : (
          members.map((member, idx) => (
            <View key={member.user_id} style={styles.memberCard}>
              <View style={styles.memberRank}>
                <Text style={styles.rankNumber}>{idx + 1}</Text>
              </View>
              <View style={styles.memberInfo}>
                <View style={styles.memberNameRow}>
                  <Text style={styles.memberName}>{member.display_name}</Text>
                  {idx === 0 && members.length > 1 && (
                    <MaterialCommunityIcons name="crown" size={16} color={Colors.light.primary} style={{ marginLeft: 4 }} />
                  )}
                  {member.is_me && (
                    <View style={styles.meBadge}>
                      <Text style={styles.meBadgeText}>you</Text>
                    </View>
                  )}
                </View>
                <Text style={styles.memberStats}>
                  {member.completed_days} {t.squads.days} · {member.failed_days} {t.squads.failures}
                </Text>
              </View>
              <Text style={styles.memberDate}>{formatJoinDate(member.joined_at)}</Text>
            </View>
          ))
        )}

        <Pressable
          style={({ pressed }) => [styles.leaveButton, pressed && { opacity: 0.7 }]}
          onPress={() => handleLeave(selectedSquad.id, selectedSquad.name)}
        >
          <Feather name="log-out" size={16} color={Colors.light.primary} />
          <Text style={styles.leaveText}>{t.squads.leaveSquad}</Text>
        </Pressable>
      </ScrollView>
    );
  }

  return (
    <View style={[styles.container, { paddingTop: Platform.OS === "web" ? 67 : insets.top + 16 }]}>
      <ScrollView contentContainerStyle={{ paddingBottom: Platform.OS === "web" ? 34 : 120 }}>
        <Text style={styles.title}>{t.squads.title}</Text>

        <View style={styles.buttonsRow}>
          <Pressable
            style={({ pressed }) => [styles.actionButton, pressed && { opacity: 0.85 }]}
            onPress={() => setShowCreate(true)}
          >
            <Feather name="plus" size={18} color={Colors.light.primary} />
            <Text style={styles.actionButtonText}>{t.squads.create}</Text>
          </Pressable>
          <Pressable
            style={({ pressed }) => [styles.actionButton, pressed && { opacity: 0.85 }]}
            onPress={() => setShowJoin(true)}
          >
            <Ionicons name="people" size={18} color={Colors.light.primary} />
            <Text style={styles.actionButtonText}>{t.squads.join}</Text>
          </Pressable>
        </View>

        {squads.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Ionicons name="people-outline" size={40} color={Colors.light.textTertiary} />
            <Text style={styles.emptyText}>{t.squads.noSquads}</Text>
            <Text style={styles.emptySubtext}>{t.squads.noSquadsDesc}</Text>
          </View>
        ) : (
          squads.map((squad) => (
            <Pressable
              key={squad.id}
              style={({ pressed }) => [styles.squadCard, pressed && { opacity: 0.9 }]}
              onPress={() => openSquadDetail(squad)}
            >
              <View>
                <Text style={styles.squadName}>{squad.name}</Text>
                <Text style={styles.squadCode}>{t.squads.code}: {squad.code}</Text>
              </View>
              <Feather name="chevron-right" size={18} color={Colors.light.textTertiary} />
            </Pressable>
          ))
        )}
      </ScrollView>

      <Modal visible={showCreate} animationType="fade" transparent>
        <Pressable style={styles.modalOverlay} onPress={() => setShowCreate(false)}>
          <Pressable style={styles.modalContent} onPress={(e) => e.stopPropagation()}>
            <Text style={styles.modalTitle}>{t.squads.createSquad}</Text>
            <Text style={styles.modalSubtitle}>{t.squads.squadName}</Text>
            <TextInput
              style={styles.modalInput}
              placeholder={t.squads.squadNamePlaceholder}
              placeholderTextColor={Colors.light.textTertiary}
              value={squadName}
              onChangeText={setSquadName}
              autoFocus
            />
            <Pressable
              style={({ pressed }) => [styles.modalButton, !squadName.trim() && styles.modalButtonDisabled, pressed && { opacity: 0.85 }]}
              onPress={handleCreate}
              disabled={!squadName.trim()}
            >
              <Text style={styles.modalButtonText}>{t.squads.create}</Text>
            </Pressable>
          </Pressable>
        </Pressable>
      </Modal>

      <Modal visible={showJoin} animationType="fade" transparent>
        <Pressable style={styles.modalOverlay} onPress={() => setShowJoin(false)}>
          <Pressable style={styles.modalContent} onPress={(e) => e.stopPropagation()}>
            <Text style={styles.modalTitle}>{t.squads.joinSquad}</Text>
            <Text style={styles.modalSubtitle}>{t.squads.squadCode}</Text>
            <TextInput
              style={styles.modalInput}
              placeholder={t.squads.squadCodePlaceholder}
              placeholderTextColor={Colors.light.textTertiary}
              value={joinCode}
              onChangeText={setJoinCode}
              autoCapitalize="none"
              autoFocus
            />
            <Pressable
              style={({ pressed }) => [styles.modalButton, !joinCode.trim() && styles.modalButtonDisabled, pressed && { opacity: 0.85 }]}
              onPress={handleJoin}
              disabled={!joinCode.trim()}
            >
              <Text style={styles.modalButtonText}>{t.squads.join}</Text>
            </Pressable>
          </Pressable>
        </Pressable>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  title: {
    fontFamily: "Rubik_700Bold",
    fontSize: 28,
    color: Colors.light.text,
    paddingHorizontal: 20,
    marginBottom: 20,
  },
  buttonsRow: {
    flexDirection: "row",
    paddingHorizontal: 20,
    gap: 12,
    marginBottom: 20,
  },
  actionButton: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
    backgroundColor: Colors.light.surface,
    borderRadius: 14,
    paddingVertical: 16,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  actionButtonText: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 15,
    color: Colors.light.text,
  },
  emptyContainer: {
    alignItems: "center",
    justifyContent: "center",
    paddingTop: 60,
    gap: 8,
  },
  emptyText: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 16,
    color: Colors.light.text,
    marginTop: 8,
  },
  emptySubtext: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
    textAlign: "center",
    paddingHorizontal: 40,
  },
  squadCard: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    backgroundColor: Colors.light.surface,
    marginHorizontal: 20,
    borderRadius: 14,
    padding: 18,
    marginBottom: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  squadName: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 16,
    color: Colors.light.text,
    marginBottom: 2,
  },
  squadCode: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textTertiary,
  },
  detailHeader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 20,
    marginBottom: 20,
  },
  detailTitle: {
    fontFamily: "Rubik_700Bold",
    fontSize: 28,
    color: Colors.light.text,
  },
  backText: {
    fontFamily: "Rubik_500Medium",
    fontSize: 15,
    color: Colors.light.textTertiary,
  },
  codeCard: {
    backgroundColor: Colors.light.surface,
    marginHorizontal: 20,
    borderRadius: 14,
    padding: 20,
    marginBottom: 24,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  codeLabel: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 11,
    color: Colors.light.textTertiary,
    letterSpacing: 1.5,
    marginBottom: 8,
  },
  codeRow: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  codeValue: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 22,
    color: Colors.light.text,
    letterSpacing: 2,
  },
  sectionLabel: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 11,
    color: Colors.light.textTertiary,
    letterSpacing: 1.5,
    paddingHorizontal: 20,
    marginBottom: 12,
  },
  noMembers: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
    textAlign: "center",
    marginTop: 20,
  },
  memberCard: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: Colors.light.surface,
    marginHorizontal: 20,
    borderRadius: 14,
    padding: 16,
    marginBottom: 8,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.03,
    shadowRadius: 4,
    elevation: 1,
  },
  memberRank: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: Colors.light.background,
    alignItems: "center",
    justifyContent: "center",
    marginRight: 12,
  },
  rankNumber: {
    fontFamily: "Rubik_700Bold",
    fontSize: 14,
    color: Colors.light.text,
  },
  memberInfo: {
    flex: 1,
  },
  memberNameRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 2,
  },
  memberName: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 15,
    color: Colors.light.text,
  },
  meBadge: {
    backgroundColor: Colors.light.primary + "20",
    borderRadius: 6,
    paddingHorizontal: 6,
    paddingVertical: 1,
    marginLeft: 6,
  },
  meBadgeText: {
    fontFamily: "Rubik_500Medium",
    fontSize: 10,
    color: Colors.light.primary,
  },
  memberStats: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textTertiary,
  },
  memberDate: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textTertiary,
  },
  leaveButton: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    paddingHorizontal: 20,
    paddingVertical: 16,
    marginTop: 12,
  },
  leaveText: {
    fontFamily: "Rubik_500Medium",
    fontSize: 14,
    color: Colors.light.primary,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 30,
  },
  modalContent: {
    backgroundColor: Colors.light.surface,
    borderRadius: 20,
    padding: 28,
    width: "100%",
    maxWidth: 360,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.15,
    shadowRadius: 24,
    elevation: 10,
  },
  modalTitle: {
    fontFamily: "Rubik_700Bold",
    fontSize: 22,
    color: Colors.light.text,
    marginBottom: 20,
  },
  modalSubtitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 11,
    color: Colors.light.textTertiary,
    letterSpacing: 1.5,
    marginBottom: 8,
  },
  modalInput: {
    fontFamily: "Rubik_400Regular",
    fontSize: 16,
    borderWidth: 1,
    borderColor: Colors.light.border,
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 14,
    marginBottom: 20,
    color: Colors.light.text,
    backgroundColor: Colors.light.background,
  },
  modalButton: {
    backgroundColor: Colors.light.primary,
    borderRadius: 14,
    paddingVertical: 16,
    alignItems: "center",
  },
  modalButtonDisabled: {
    opacity: 0.4,
  },
  modalButtonText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 16,
    color: "#fff",
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\(tabs)\trophies.tsx ===
import React from "react";
import { StyleSheet, Text, View, ScrollView, Platform } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { Ionicons, MaterialCommunityIcons, Feather, FontAwesome } from "@expo/vector-icons";
import Colors from "@/constants/colors";
import { useRigor } from "@/lib/rigor-context";
import { useI18n } from "@/lib/i18n";

interface Achievement {
  id: string;
  nameKey: string;
  descKey: string;
  target: number;
  icon: React.ReactNode;
  iconBgColor: string;
}

const achievementDefs: Achievement[] = [
  { id: '1', nameKey: 'firstStep', descKey: 'firstStepDesc', target: 1, icon: <Ionicons name="flash" size={18} color={Colors.light.primary} />, iconBgColor: '#FFF3E0' },
  { id: '2', nameKey: 'solidStart', descKey: 'solidStartDesc', target: 3, icon: <Ionicons name="flash-outline" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '3', nameKey: 'steadyHand', descKey: 'steadyHandDesc', target: 5, icon: <Feather name="target" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '4', nameKey: 'weekWarrior', descKey: 'weekWarriorDesc', target: 7, icon: <MaterialCommunityIcons name="shield-outline" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '5', nameKey: 'doubleDigits', descKey: 'doubleDigitsDesc', target: 10, icon: <Ionicons name="diamond-outline" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '6', nameKey: 'twoWeeks', descKey: 'twoWeeksDesc', target: 14, icon: <Feather name="calendar" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '7', nameKey: 'habit21', descKey: 'habit21Desc', target: 21, icon: <MaterialCommunityIcons name="circle-multiple-outline" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '8', nameKey: 'monthMaster', descKey: 'monthMasterDesc', target: 30, icon: <FontAwesome name="star-o" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '9', nameKey: 'halfwayThere', descKey: 'halfwayThereDesc', target: 33, icon: <Ionicons name="flag-outline" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '10', nameKey: 'ironWill', descKey: 'ironWillDesc', target: 40, icon: <Feather name="shield" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '11', nameKey: 'unstoppable', descKey: 'unstoppableDesc', target: 50, icon: <Ionicons name="rocket-outline" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '12', nameKey: 'diamondHands', descKey: 'diamondHandsDesc', target: 60, icon: <Ionicons name="diamond-outline" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '13', nameKey: 'trueDiscipline', descKey: 'trueDisciplineDesc', target: 66, icon: <MaterialCommunityIcons name="crown-outline" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '14', nameKey: 'zeroFails', descKey: 'zeroFailsDesc', target: -1, icon: <Ionicons name="checkmark-done-outline" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
  { id: '15', nameKey: 'legend', descKey: 'legendDesc', target: -2, icon: <Ionicons name="medal-outline" size={18} color={Colors.light.textTertiary} />, iconBgColor: Colors.light.surfaceSecondary },
];

export default function TrophiesScreen() {
  const insets = useSafeAreaInsets();
  const { getCompletedCount } = useRigor();
  const { t } = useI18n();
  const completed = getCompletedCount();

  const unlockedCount = achievementDefs.filter(a => a.target > 0 && completed >= a.target).length;
  const totalProgress = Math.round((unlockedCount / achievementDefs.length) * 100);

  const achievements = t.trophies.achievements;

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={{ paddingTop: Platform.OS === 'web' ? 67 : insets.top + 16, paddingBottom: 120 }}
      contentInsetAdjustmentBehavior="automatic"
    >
      <View style={styles.headerRow}>
        <View>
          <Text style={styles.title}>{t.trophies.title}</Text>
          <Text style={styles.subtitle}>{completed} {t.trophies.daysCompleted}</Text>
        </View>
        <Text style={styles.counter}>{unlockedCount}/{achievementDefs.length}</Text>
      </View>

      <View style={styles.progressRow}>
        <View style={styles.progressBar}>
          <View style={[styles.progressFill, { width: `${totalProgress}%` }]} />
        </View>
        <Text style={styles.progressPercent}>{totalProgress}%</Text>
      </View>

      {achievementDefs.map((def) => {
        const unlocked = def.target > 0 && completed >= def.target;
        const progress = def.target > 0 ? Math.min(completed, def.target) : 0;
        const name = achievements[def.nameKey as keyof typeof achievements] || def.nameKey;
        const desc = achievements[def.descKey as keyof typeof achievements] || def.descKey;

        return (
          <View key={def.id} style={styles.achievementCard}>
            <View style={[styles.achievementIcon, { backgroundColor: unlocked ? '#FFF3E0' : Colors.light.surfaceSecondary }]}>
              {unlocked ? (
                <Ionicons name="flash" size={18} color={Colors.light.primary} />
              ) : def.icon}
            </View>
            <View style={styles.achievementInfo}>
              <Text style={[styles.achievementName, !unlocked && { color: Colors.light.textTertiary }]}>
                {name}
              </Text>
              <Text style={styles.achievementDesc}>{desc}</Text>
            </View>
            {def.target > 0 && (
              <Text style={[styles.achievementProgress, unlocked && { color: Colors.light.primary }]}>
                {progress}/{def.target}
              </Text>
            )}
          </View>
        );
      })}
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  headerRow: {
    flexDirection: "row",
    alignItems: "flex-start",
    justifyContent: "space-between",
    paddingHorizontal: 20,
    marginBottom: 12,
  },
  title: {
    fontFamily: "Rubik_700Bold",
    fontSize: 28,
    color: Colors.light.text,
  },
  subtitle: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
    marginTop: 2,
  },
  counter: {
    fontFamily: "Rubik_700Bold",
    fontSize: 20,
    color: Colors.light.text,
    marginTop: 6,
  },
  progressRow: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 20,
    gap: 12,
    marginBottom: 24,
  },
  progressBar: {
    flex: 1,
    height: 6,
    backgroundColor: Colors.light.progressBg,
    borderRadius: 3,
    overflow: "hidden",
  },
  progressFill: {
    height: "100%",
    backgroundColor: Colors.light.primary,
    borderRadius: 3,
  },
  progressPercent: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 13,
    color: Colors.light.primary,
  },
  achievementCard: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 20,
    paddingVertical: 14,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.borderLight,
  },
  achievementIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    alignItems: "center",
    justifyContent: "center",
    marginRight: 14,
  },
  achievementInfo: {
    flex: 1,
  },
  achievementName: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 15,
    color: Colors.light.text,
    marginBottom: 2,
  },
  achievementDesc: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textTertiary,
  },
  achievementProgress: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 14,
    color: Colors.light.textTertiary,
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\(tabs)\_layout.tsx ===
import { isLiquidGlassAvailable } from "expo-glass-effect";
import { Tabs, Redirect } from "expo-router";
import { NativeTabs, Icon, Label } from "expo-router/unstable-native-tabs";
import { BlurView } from "expo-blur";
import { Platform, StyleSheet, View } from "react-native";
import { Ionicons, MaterialCommunityIcons, Feather } from "@expo/vector-icons";
import React from "react";
import Colors from "@/constants/colors";
import { useAuth } from "@/lib/auth-context";
import { useI18n } from "@/lib/i18n";

function NativeTabLayout() {
  const { t } = useI18n();
  return (
    <NativeTabs>
      <NativeTabs.Trigger name="index">
        <Icon sf={{ default: "target", selected: "target" }} />
        <Label>{t.tabs.today}</Label>
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="progress">
        <Icon sf={{ default: "chart.bar", selected: "chart.bar.fill" }} />
        <Label>{t.tabs.progress}</Label>
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="squads">
        <Icon sf={{ default: "person.3", selected: "person.3.fill" }} />
        <Label>{t.tabs.squads}</Label>
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="trophies">
        <Icon sf={{ default: "trophy", selected: "trophy.fill" }} />
        <Label>{t.tabs.trophies}</Label>
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="profile">
        <Icon sf={{ default: "gearshape", selected: "gearshape.fill" }} />
        <Label>{t.tabs.profile}</Label>
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}

function ClassicTabLayout() {
  const isWeb = Platform.OS === "web";
  const isIOS = Platform.OS === "ios";
  const { t } = useI18n();

  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarActiveTintColor: Colors.light.primary,
        tabBarInactiveTintColor: Colors.light.textTertiary,
        tabBarLabelStyle: {
          fontFamily: "Rubik_500Medium",
          fontSize: 10,
          marginTop: -2,
        },
        tabBarStyle: {
          position: "absolute",
          backgroundColor: isIOS ? "transparent" : Colors.light.surface,
          borderTopWidth: isWeb ? 1 : 0,
          borderTopColor: Colors.light.border,
          elevation: 0,
          ...(isWeb ? { height: 84 } : {}),
        },
        tabBarBackground: () =>
          isIOS ? (
            <BlurView
              intensity={100}
              tint="light"
              style={StyleSheet.absoluteFill}
            />
          ) : isWeb ? (
            <View style={[StyleSheet.absoluteFill, { backgroundColor: Colors.light.surface }]} />
          ) : null,
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: t.tabs.today,
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="radio-button-on" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="progress"
        options={{
          title: t.tabs.progress,
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="grid" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="squads"
        options={{
          title: t.tabs.squads,
          tabBarIcon: ({ color, size }) => (
            <MaterialCommunityIcons name="account-group" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="trophies"
        options={{
          title: t.tabs.trophies,
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="trophy" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="profile"
        options={{
          title: t.tabs.profile,
          tabBarIcon: ({ color, size }) => (
            <Feather name="settings" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

export default function TabLayout() {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) return null;
  if (!isAuthenticated) return <Redirect href="/(auth)/login" />;

  if (isLiquidGlassAvailable()) {
    return <NativeTabLayout />;
  }
  return <ClassicTabLayout />;
}

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\+native-intent.tsx ===
export function redirectSystemPath({
  path,
  initial,
}: { path: string; initial: boolean }) {
  return '/';
}

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\+not-found.tsx ===
// template
import { Link, Stack } from "expo-router";
import { StyleSheet, Text, View } from "react-native";

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: "Oops!" }} />
      <View style={styles.container}>
        <Text style={styles.title}>This screen doesn&apos;t exist.</Text>

        <Link href="/" style={styles.link}>
          <Text style={styles.linkText}>Go to home screen!</Text>
        </Link>
      </View>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
    padding: 20,
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
  linkText: {
    fontSize: 14,
    color: "#2e78b7",
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\about.tsx ===
import React from "react";
import { StyleSheet, Text, View, Pressable, Platform, ScrollView } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { router } from "expo-router";
import { Feather, Ionicons } from "@expo/vector-icons";
import Colors from "@/constants/colors";
import { useI18n } from "@/lib/i18n";

export default function AboutScreen() {
  const insets = useSafeAreaInsets();
  const { t } = useI18n();

  return (
    <View style={[styles.container, { paddingTop: Platform.OS === "web" ? 67 : insets.top }]}>
      <View style={styles.header}>
        <Pressable onPress={() => router.back()} style={styles.closeBtn}>
          <Feather name="x" size={24} color={Colors.light.text} />
        </Pressable>
        <Text style={styles.headerTitle}>{t.about.title}</Text>
        <View style={{ width: 32 }} />
      </View>

      <ScrollView contentContainerStyle={styles.content}>
        <View style={styles.logoSection}>
          <View style={styles.logoIcon}>
            <Feather name="target" size={36} color="#fff" />
          </View>
          <Text style={styles.appName}>RIGOR</Text>
          <Text style={styles.version}>{t.about.version}</Text>
        </View>

        <Text style={styles.description}>{t.about.description}</Text>

        <View style={styles.featureList}>
          <View style={styles.featureItem}>
            <View style={[styles.featureIcon, { backgroundColor: "#FFF3E0" }]}>
              <Feather name="file-text" size={18} color={Colors.light.primary} />
            </View>
            <View style={styles.featureText}>
              <Text style={styles.featureTitle}>{t.about.irreversibleContracts}</Text>
              <Text style={styles.featureDesc}>{t.about.irreversibleContractsDesc}</Text>
            </View>
          </View>

          <View style={styles.featureItem}>
            <View style={[styles.featureIcon, { backgroundColor: "#E8F5E9" }]}>
              <Ionicons name="grid" size={18} color={Colors.light.success} />
            </View>
            <View style={styles.featureText}>
              <Text style={styles.featureTitle}>{t.about.consistencyHeatmap}</Text>
              <Text style={styles.featureDesc}>{t.about.consistencyHeatmapDesc}</Text>
            </View>
          </View>

          <View style={styles.featureItem}>
            <View style={[styles.featureIcon, { backgroundColor: "#E3F2FD" }]}>
              <Ionicons name="people" size={18} color="#1976D2" />
            </View>
            <View style={styles.featureText}>
              <Text style={styles.featureTitle}>{t.about.squads}</Text>
              <Text style={styles.featureDesc}>{t.about.squadsDesc}</Text>
            </View>
          </View>

          <View style={styles.featureItem}>
            <View style={[styles.featureIcon, { backgroundColor: "#FFF8E1" }]}>
              <Ionicons name="trophy" size={18} color="#F9A825" />
            </View>
            <View style={styles.featureText}>
              <Text style={styles.featureTitle}>{t.about.trophies}</Text>
              <Text style={styles.featureDesc}>{t.about.trophiesDesc}</Text>
            </View>
          </View>

          <View style={styles.featureItem}>
            <View style={[styles.featureIcon, { backgroundColor: "#FCE4EC" }]}>
              <Ionicons name="timer" size={18} color={Colors.light.error} />
            </View>
            <View style={styles.featureText}>
              <Text style={styles.featureTitle}>{t.about.shrinkingDeadlines}</Text>
              <Text style={styles.featureDesc}>{t.about.shrinkingDeadlinesDesc}</Text>
            </View>
          </View>
        </View>

        <Text style={styles.footer}>{t.about.footer}</Text>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    paddingVertical: 14,
  },
  closeBtn: {
    padding: 4,
  },
  headerTitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 17,
    color: Colors.light.text,
  },
  content: {
    paddingHorizontal: 24,
    paddingBottom: 60,
  },
  logoSection: {
    alignItems: "center",
    marginBottom: 28,
    marginTop: 12,
  },
  logoIcon: {
    width: 72,
    height: 72,
    borderRadius: 22,
    backgroundColor: Colors.light.primary,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 14,
  },
  appName: {
    fontFamily: "Rubik_800ExtraBold",
    fontSize: 28,
    color: Colors.light.text,
    letterSpacing: 4,
  },
  version: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
    marginTop: 4,
  },
  description: {
    fontFamily: "Rubik_400Regular",
    fontSize: 15,
    color: Colors.light.textSecondary,
    lineHeight: 22,
    textAlign: "center",
    marginBottom: 32,
  },
  featureList: {
    gap: 16,
    marginBottom: 32,
  },
  featureItem: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: Colors.light.surface,
    borderRadius: 14,
    padding: 16,
    gap: 14,
  },
  featureIcon: {
    width: 40,
    height: 40,
    borderRadius: 12,
    alignItems: "center",
    justifyContent: "center",
  },
  featureText: {
    flex: 1,
  },
  featureTitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 14,
    color: Colors.light.text,
    marginBottom: 2,
  },
  featureDesc: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textTertiary,
  },
  footer: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textTertiary,
    textAlign: "center",
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\create-contract.tsx ===
import React, { useState } from "react";
import { StyleSheet, Text, View, Pressable, TextInput, ScrollView, Platform } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { router } from "expo-router";
import { Feather, Ionicons } from "@expo/vector-icons";
import * as Haptics from "expo-haptics";
import Animated, { FadeInDown } from "react-native-reanimated";
import Colors from "@/constants/colors";
import { useRigor } from "@/lib/rigor-context";
import { useI18n } from "@/lib/i18n";

const DURATIONS = [14, 30, 66];

export default function CreateContractScreen() {
  const insets = useSafeAreaInsets();
  const { signContract } = useRigor();
  const { t } = useI18n();
  const [step, setStep] = useState(0);
  const [rule, setRule] = useState("");
  const [deadlineHour, setDeadlineHour] = useState(23);
  const [deadlineMinute, setDeadlineMinute] = useState(0);
  const [duration, setDuration] = useState(30);

  const handleSign = async () => {
    if (!rule.trim()) return;
    if (Platform.OS !== 'web') {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }
    await signContract(rule.trim(), deadlineHour, deadlineMinute, duration);
    router.back();
  };

  const adjustHour = (delta: number) => {
    setDeadlineHour((prev) => {
      const next = prev + delta;
      if (next < 0) return 23;
      if (next > 23) return 0;
      return next;
    });
    if (Platform.OS !== 'web') Haptics.selectionAsync();
  };

  const adjustMinute = (delta: number) => {
    setDeadlineMinute((prev) => {
      const next = prev + delta;
      if (next < 0) return 45;
      if (next > 59) return 0;
      return Math.floor(next / 15) * 15;
    });
    if (Platform.OS !== 'web') Haptics.selectionAsync();
  };

  return (
    <View style={[styles.container, { paddingTop: Platform.OS === 'web' ? 67 : insets.top }]}>
      <View style={styles.header}>
        <Pressable onPress={() => router.back()} style={styles.closeBtn}>
          <Feather name="x" size={24} color={Colors.light.text} />
        </Pressable>
        <Text style={styles.headerTitle}>{t.createContract.title}</Text>
        <View style={{ width: 32 }} />
      </View>

      <ScrollView contentContainerStyle={styles.content} keyboardShouldPersistTaps="handled">
        {step === 0 && (
          <Animated.View entering={Platform.OS !== 'web' ? FadeInDown.duration(300) : undefined}>
            <View style={styles.stepBadge}>
              <Text style={styles.stepBadgeText}>01</Text>
            </View>
            <Text style={styles.stepTitle}>{t.createContract.step1Title}</Text>
            <Text style={styles.stepDesc}>{t.createContract.step1Desc}</Text>
            <TextInput
              style={styles.ruleInput}
              placeholder={t.createContract.inputPlaceholder}
              placeholderTextColor={Colors.light.textTertiary}
              value={rule}
              onChangeText={setRule}
              autoFocus
              multiline={false}
            />
            <View style={styles.examplesContainer}>
              {['Workout', 'Study for 1 hour', 'Wake up at 5am', 'No sugar', 'Read 30 pages'].map((ex) => (
                <Pressable
                  key={ex}
                  style={({ pressed }) => [styles.exampleChip, pressed && { opacity: 0.7 }]}
                  onPress={() => setRule(ex)}
                >
                  <Text style={styles.exampleText}>{ex}</Text>
                </Pressable>
              ))}
            </View>
            <Pressable
              style={({ pressed }) => [styles.nextButton, !rule.trim() && { opacity: 0.4 }, pressed && { opacity: 0.85 }]}
              onPress={() => rule.trim() && setStep(1)}
              disabled={!rule.trim()}
            >
              <Text style={styles.nextButtonText}>{t.createContract.next}</Text>
            </Pressable>
          </Animated.View>
        )}

        {step === 1 && (
          <Animated.View entering={Platform.OS !== 'web' ? FadeInDown.duration(300) : undefined}>
            <View style={styles.stepBadge}>
              <Text style={styles.stepBadgeText}>02</Text>
            </View>
            <Text style={styles.stepTitle}>{t.createContract.step2Title}</Text>
            <Text style={styles.stepDesc}>{t.createContract.step2Desc}</Text>

            <View style={styles.timePickerContainer}>
              <View style={styles.timeColumn}>
                <Pressable onPress={() => adjustHour(1)} style={styles.timeArrow}>
                  <Feather name="chevron-up" size={28} color={Colors.light.textTertiary} />
                </Pressable>
                <Text style={styles.timeValue}>{deadlineHour.toString().padStart(2, '0')}</Text>
                <Pressable onPress={() => adjustHour(-1)} style={styles.timeArrow}>
                  <Feather name="chevron-down" size={28} color={Colors.light.textTertiary} />
                </Pressable>
              </View>
              <Text style={styles.timeSeparator}>:</Text>
              <View style={styles.timeColumn}>
                <Pressable onPress={() => adjustMinute(15)} style={styles.timeArrow}>
                  <Feather name="chevron-up" size={28} color={Colors.light.textTertiary} />
                </Pressable>
                <Text style={styles.timeValue}>{deadlineMinute.toString().padStart(2, '0')}</Text>
                <Pressable onPress={() => adjustMinute(-15)} style={styles.timeArrow}>
                  <Feather name="chevron-down" size={28} color={Colors.light.textTertiary} />
                </Pressable>
              </View>
            </View>

            <Text style={styles.deadlineNote}>{t.createContract.deadlineNote}</Text>

            <View style={styles.buttonRow}>
              <Pressable style={({ pressed }) => [styles.backButton, pressed && { opacity: 0.7 }]} onPress={() => setStep(0)}>
                <Feather name="arrow-left" size={20} color={Colors.light.text} />
              </Pressable>
              <Pressable
                style={({ pressed }) => [styles.nextButton, { flex: 1 }, pressed && { opacity: 0.85 }]}
                onPress={() => setStep(2)}
              >
                <Text style={styles.nextButtonText}>{t.createContract.next}</Text>
              </Pressable>
            </View>
          </Animated.View>
        )}

        {step === 2 && (
          <Animated.View entering={Platform.OS !== 'web' ? FadeInDown.duration(300) : undefined}>
            <View style={styles.stepBadge}>
              <Text style={styles.stepBadgeText}>03</Text>
            </View>
            <Text style={styles.stepTitle}>{t.createContract.step3Title}</Text>
            <Text style={styles.stepDesc}>{t.createContract.step3Desc}</Text>

            <View style={styles.durationOptions}>
              {DURATIONS.map((d) => (
                <Pressable
                  key={d}
                  style={[styles.durationOption, duration === d && styles.durationSelected]}
                  onPress={() => {
                    setDuration(d);
                    if (Platform.OS !== 'web') Haptics.selectionAsync();
                  }}
                >
                  <Text style={[styles.durationNumber, duration === d && styles.durationNumberSelected]}>{d}</Text>
                  <Text style={[styles.durationLabel, duration === d && styles.durationLabelSelected]}>{t.createContract.days}</Text>
                </Pressable>
              ))}
            </View>

            <View style={styles.contractSummary}>
              <Text style={styles.summaryTitle}>{t.createContract.contractSummary}</Text>
              <View style={styles.summaryRow}>
                <Text style={styles.summaryLabel}>{t.createContract.rule}</Text>
                <Text style={styles.summaryValue}>{rule}</Text>
              </View>
              <View style={styles.summaryRow}>
                <Text style={styles.summaryLabel}>{t.createContract.deadline}</Text>
                <Text style={styles.summaryValue}>
                  {deadlineHour.toString().padStart(2, '0')}:{deadlineMinute.toString().padStart(2, '0')}
                </Text>
              </View>
              <View style={[styles.summaryRow, { borderBottomWidth: 0 }]}>
                <Text style={styles.summaryLabel}>{t.createContract.duration}</Text>
                <Text style={styles.summaryValue}>{duration} {t.createContract.days}</Text>
              </View>
            </View>

            <View style={styles.warningBox}>
              <Ionicons name="warning" size={16} color={Colors.light.primary} />
              <Text style={styles.warningText}>{t.createContract.warning}</Text>
            </View>

            <View style={styles.buttonRow}>
              <Pressable style={({ pressed }) => [styles.backButton, pressed && { opacity: 0.7 }]} onPress={() => setStep(1)}>
                <Feather name="arrow-left" size={20} color={Colors.light.text} />
              </Pressable>
              <Pressable
                style={({ pressed }) => [styles.signButton, { flex: 1 }, pressed && { opacity: 0.85 }]}
                onPress={handleSign}
              >
                <Text style={styles.signButtonText}>{t.createContract.signContract}</Text>
              </Pressable>
            </View>
          </Animated.View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    paddingVertical: 14,
  },
  closeBtn: {
    padding: 4,
  },
  headerTitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 17,
    color: Colors.light.text,
  },
  content: {
    paddingHorizontal: 24,
    paddingTop: 16,
    paddingBottom: 60,
  },
  stepBadge: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: Colors.light.primary,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 16,
  },
  stepBadgeText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 14,
    color: "#fff",
  },
  stepTitle: {
    fontFamily: "Rubik_700Bold",
    fontSize: 24,
    color: Colors.light.text,
    marginBottom: 8,
  },
  stepDesc: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
    lineHeight: 20,
    marginBottom: 24,
  },
  ruleInput: {
    fontFamily: "Rubik_400Regular",
    fontSize: 16,
    borderWidth: 1.5,
    borderColor: Colors.light.border,
    borderRadius: 14,
    paddingHorizontal: 18,
    paddingVertical: 16,
    color: Colors.light.text,
    backgroundColor: Colors.light.surface,
    marginBottom: 16,
  },
  examplesContainer: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 8,
    marginBottom: 32,
  },
  exampleChip: {
    backgroundColor: Colors.light.surfaceSecondary,
    borderRadius: 20,
    paddingHorizontal: 14,
    paddingVertical: 8,
  },
  exampleText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textSecondary,
  },
  nextButton: {
    backgroundColor: Colors.light.primary,
    borderRadius: 14,
    paddingVertical: 16,
    alignItems: "center",
  },
  nextButtonText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 16,
    color: "#fff",
  },
  timePickerContainer: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 12,
    marginBottom: 20,
  },
  timeColumn: {
    alignItems: "center",
    gap: 4,
  },
  timeArrow: {
    padding: 8,
  },
  timeValue: {
    fontFamily: "Rubik_700Bold",
    fontSize: 48,
    color: Colors.light.text,
    width: 80,
    textAlign: "center",
  },
  timeSeparator: {
    fontFamily: "Rubik_700Bold",
    fontSize: 48,
    color: Colors.light.text,
  },
  deadlineNote: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textTertiary,
    textAlign: "center",
    marginBottom: 32,
  },
  buttonRow: {
    flexDirection: "row",
    gap: 12,
    alignItems: "stretch",
  },
  backButton: {
    width: 52,
    height: 52,
    borderRadius: 14,
    borderWidth: 1.5,
    borderColor: Colors.light.border,
    alignItems: "center",
    justifyContent: "center",
  },
  durationOptions: {
    flexDirection: "row",
    gap: 12,
    marginBottom: 24,
  },
  durationOption: {
    flex: 1,
    backgroundColor: Colors.light.surface,
    borderRadius: 14,
    paddingVertical: 24,
    alignItems: "center",
    borderWidth: 2,
    borderColor: Colors.light.border,
  },
  durationSelected: {
    borderColor: Colors.light.primary,
    backgroundColor: '#FFF3E0',
  },
  durationNumber: {
    fontFamily: "Rubik_700Bold",
    fontSize: 28,
    color: Colors.light.text,
  },
  durationNumberSelected: {
    color: Colors.light.primary,
  },
  durationLabel: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
    marginTop: 2,
  },
  durationLabelSelected: {
    color: Colors.light.primary,
  },
  contractSummary: {
    backgroundColor: Colors.light.surface,
    borderRadius: 14,
    padding: 18,
    marginBottom: 16,
  },
  summaryTitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 14,
    color: Colors.light.text,
    marginBottom: 12,
  },
  summaryRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingVertical: 8,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.borderLight,
  },
  summaryLabel: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
  },
  summaryValue: {
    fontFamily: "Rubik_500Medium",
    fontSize: 14,
    color: Colors.light.text,
  },
  warningBox: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    backgroundColor: '#FFF3E0',
    borderRadius: 12,
    padding: 14,
    marginBottom: 24,
  },
  warningText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textSecondary,
    flex: 1,
    lineHeight: 18,
  },
  signButton: {
    backgroundColor: Colors.light.text,
    borderRadius: 14,
    paddingVertical: 16,
    alignItems: "center",
  },
  signButtonText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 16,
    color: "#fff",
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\share-card.tsx ===
import React, { useRef, useCallback } from "react";
import { StyleSheet, Text, View, Pressable, Platform, ScrollView, Alert } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { router } from "expo-router";
import { Feather } from "@expo/vector-icons";
import ViewShot from "react-native-view-shot";
import * as Sharing from "expo-sharing";
import Colors from "@/constants/colors";
import { useRigor } from "@/lib/rigor-context";
import { useI18n } from "@/lib/i18n";

const CARD_BG = "#1A1A1A";
const CARD_TEXT = "#FAFAFA";
const CARD_MUTED = "#999999";
const CARD_ORANGE = "#E8611A";
const CARD_RED = "#E53935";
const DOT_EMPTY = "#D4D4D4";
const DOTS_PER_ROW = 10;

export default function ShareCardScreen() {
  const insets = useSafeAreaInsets();
  const viewShotRef = useRef<ViewShot>(null);
  const { contract, dayRecords, getDayNumber, getCompletedCount, getFailedCount, getCompletionRate } = useRigor();
  const { t } = useI18n();

  const dayNumber = getDayNumber();
  const completed = getCompletedCount();
  const failed = getFailedCount();
  const rate = getCompletionRate();
  const duration = contract?.duration ?? 30;
  const ruleText = contract?.rule ?? "";

  const buildDotGrid = useCallback(() => {
    if (!contract) return [];
    const totalDays = contract.duration;
    const dots: Array<{ day: number; status: "completed" | "failed" | "critical" | "pending" }> = [];

    for (let i = 0; i < totalDays; i++) {
      const d = new Date(contract.start_date + "T00:00:00");
      d.setDate(d.getDate() + i);
      const dateStr = d.toISOString().split("T")[0];
      const record = dayRecords.find((r) => r.date === dateStr);

      if (record) {
        if (record.critical) dots.push({ day: i + 1, status: "critical" });
        else if (record.failed) dots.push({ day: i + 1, status: "failed" });
        else if (record.completed) dots.push({ day: i + 1, status: "completed" });
        else dots.push({ day: i + 1, status: "pending" });
      } else {
        dots.push({ day: i + 1, status: "pending" });
      }
    }
    return dots;
  }, [contract, dayRecords]);

  const dots = buildDotGrid();
  const rows: typeof dots[] = [];
  for (let i = 0; i < dots.length; i += DOTS_PER_ROW) {
    rows.push(dots.slice(i, i + DOTS_PER_ROW));
  }

  const getDotColor = (status: string) => {
    switch (status) {
      case "completed": return CARD_ORANGE;
      case "failed": return CARD_MUTED;
      case "critical": return CARD_RED;
      default: return DOT_EMPTY;
    }
  };

  const handleDownload = async () => {
    try {
      if (!viewShotRef.current?.capture) return;
      const uri = await viewShotRef.current.capture();

      if (Platform.OS === "web") {
        const link = document.createElement("a");
        link.href = uri;
        link.download = `rigor-day-${dayNumber}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } else {
        const isAvailable = await Sharing.isAvailableAsync();
        if (isAvailable) {
          await Sharing.shareAsync(uri, {
            mimeType: "image/png",
            dialogTitle: "Share your RIGOR progress",
          });
        } else {
          Alert.alert("Sharing not available on this device");
        }
      }
    } catch (e) {
      console.error("Failed to capture/share:", e);
    }
  };

  if (!contract) {
    router.back();
    return null;
  }

  return (
    <View style={[styles.container, { paddingTop: Platform.OS === "web" ? 67 : insets.top }]}>
      <View style={styles.topBar}>
        <View style={{ width: 32 }} />
        <Text style={styles.topBarTitle}>{t.shareCard.title}</Text>
        <Pressable onPress={() => router.back()} hitSlop={12}>
          <Feather name="x" size={24} color={Colors.light.text} />
        </Pressable>
      </View>

      <ScrollView
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        <ViewShot
          ref={viewShotRef}
          options={{ format: "png", quality: 1.0 }}
          style={styles.cardWrapper}
        >
          <View style={styles.card}>
            <View style={styles.cardHeader}>
              <Text style={styles.cardLogo}>RIGOR</Text>
              <Text style={styles.cardDay}>{t.shareCard.day} {dayNumber}</Text>
            </View>

            <Text style={styles.cardRule}>{ruleText}</Text>

            <Text style={styles.mapLabel}>{t.shareCard.consistencyMap}</Text>

            <View style={styles.dotGrid}>
              {rows.map((row, rowIdx) => (
                <View key={rowIdx} style={styles.dotRow}>
                  {row.map((dot, dotIdx) => (
                    <View
                      key={dotIdx}
                      style={[
                        styles.dot,
                        { backgroundColor: getDotColor(dot.status) },
                      ]}
                    />
                  ))}
                </View>
              ))}
            </View>

            <View style={styles.legend}>
              <View style={styles.legendItem}>
                <View style={[styles.legendDot, { backgroundColor: CARD_ORANGE }]} />
                <Text style={styles.legendText}>{t.shareCard.completed}</Text>
              </View>
              <View style={styles.legendItem}>
                <View style={[styles.legendDot, { backgroundColor: CARD_MUTED }]} />
                <Text style={styles.legendText}>{t.shareCard.failed}</Text>
              </View>
              <View style={styles.legendItem}>
                <View style={[styles.legendDot, { backgroundColor: CARD_RED }]} />
                <Text style={styles.legendText}>{t.shareCard.critical}</Text>
              </View>
            </View>

            <View style={styles.statsRow}>
              <View style={styles.statBlock}>
                <Text style={styles.statValue}>{rate}%</Text>
                <Text style={styles.statLabel}>{t.shareCard.rate}</Text>
              </View>
              <View style={styles.statBlock}>
                <Text style={styles.statValue}>{completed}</Text>
                <Text style={styles.statLabel}>{t.shareCard.completed}</Text>
              </View>
              <View style={styles.statBlock}>
                <Text style={styles.statValue}>{duration}d</Text>
                <Text style={styles.statLabel}>{t.shareCard.contract}</Text>
              </View>
            </View>
          </View>
        </ViewShot>

        <Pressable
          style={({ pressed }) => [styles.downloadButton, pressed && { opacity: 0.85, transform: [{ scale: 0.97 }] }]}
          onPress={handleDownload}
        >
          <Feather name="download" size={20} color="#fff" style={{ marginRight: 10 }} />
          <Text style={styles.downloadText}>{t.shareCard.download}</Text>
        </Pressable>

        <Text style={styles.hint}>{t.shareCard.hint}</Text>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  topBar: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 20,
    paddingVertical: 14,
  },
  topBarTitle: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 16,
    color: Colors.light.text,
  },
  scrollContent: {
    alignItems: "center",
    paddingHorizontal: 20,
    paddingBottom: 40,
  },
  cardWrapper: {
    width: "100%",
    borderRadius: 20,
    overflow: "hidden",
    marginTop: 12,
  },
  card: {
    backgroundColor: CARD_BG,
    borderRadius: 20,
    padding: 24,
  },
  cardHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 8,
  },
  cardLogo: {
    fontFamily: "Rubik_800ExtraBold",
    fontSize: 20,
    color: CARD_TEXT,
    letterSpacing: 1,
  },
  cardDay: {
    fontFamily: "Rubik_700Bold",
    fontSize: 18,
    color: CARD_ORANGE,
    letterSpacing: 0.5,
  },
  cardRule: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: CARD_MUTED,
    marginBottom: 20,
  },
  mapLabel: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 11,
    color: CARD_MUTED,
    letterSpacing: 1.5,
    marginBottom: 14,
  },
  dotGrid: {
    gap: 6,
    marginBottom: 14,
  },
  dotRow: {
    flexDirection: "row",
    gap: 6,
    justifyContent: "flex-start",
  },
  dot: {
    width: 26,
    height: 26,
    borderRadius: 13,
  },
  legend: {
    flexDirection: "row",
    gap: 18,
    marginBottom: 24,
  },
  legendItem: {
    flexDirection: "row",
    alignItems: "center",
    gap: 6,
  },
  legendDot: {
    width: 10,
    height: 10,
    borderRadius: 2,
  },
  legendText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: CARD_MUTED,
  },
  statsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    paddingTop: 4,
  },
  statBlock: {
    alignItems: "flex-start",
  },
  statValue: {
    fontFamily: "Rubik_700Bold",
    fontSize: 26,
    color: CARD_TEXT,
  },
  statLabel: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: CARD_MUTED,
    marginTop: 2,
  },
  downloadButton: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: CARD_ORANGE,
    borderRadius: 50,
    paddingVertical: 16,
    paddingHorizontal: 40,
    marginTop: 28,
    width: "100%",
    maxWidth: 320,
  },
  downloadText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 16,
    color: "#fff",
  },
  hint: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
    marginTop: 12,
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\app\_layout.tsx ===
import { QueryClientProvider } from "@tanstack/react-query";
import { Stack } from "expo-router";
import * as SplashScreen from "expo-splash-screen";
import React, { useEffect } from "react";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import { KeyboardProvider } from "react-native-keyboard-controller";
import { ErrorBoundary } from "@/components/ErrorBoundary";
import { queryClient } from "@/lib/query-client";
import { AuthProvider } from "@/lib/auth-context";
import { RigorProvider } from "@/lib/rigor-context";
import { I18nProvider } from "@/lib/i18n";
import { useFonts, Rubik_400Regular, Rubik_500Medium, Rubik_600SemiBold, Rubik_700Bold, Rubik_800ExtraBold } from "@expo-google-fonts/rubik";

SplashScreen.preventAutoHideAsync();

function RootLayoutNav() {
  return (
    <Stack screenOptions={{ headerBackTitle: "Back" }}>
      <Stack.Screen name="(auth)" options={{ headerShown: false }} />
      <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
      <Stack.Screen name="create-contract" options={{ headerShown: false, presentation: "modal" }} />
      <Stack.Screen name="about" options={{ headerShown: false, presentation: "modal" }} />
      <Stack.Screen name="share-card" options={{ headerShown: false, presentation: "modal" }} />
    </Stack>
  );
}

export default function RootLayout() {
  const [fontsLoaded] = useFonts({
    Rubik_400Regular,
    Rubik_500Medium,
    Rubik_600SemiBold,
    Rubik_700Bold,
    Rubik_800ExtraBold,
  });

  useEffect(() => {
    if (fontsLoaded) {
      SplashScreen.hideAsync();
    }
  }, [fontsLoaded]);

  if (!fontsLoaded) return null;

  return (
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <GestureHandlerRootView>
          <KeyboardProvider>
            <I18nProvider>
              <AuthProvider>
                <RigorProvider>
                  <RootLayoutNav />
                </RigorProvider>
              </AuthProvider>
            </I18nProvider>
          </KeyboardProvider>
        </GestureHandlerRootView>
      </QueryClientProvider>
    </ErrorBoundary>
  );
}

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\components\ErrorBoundary.tsx ===
import React, { Component, ComponentType, PropsWithChildren } from "react";
import { ErrorFallback, ErrorFallbackProps } from "@/components/ErrorFallback";

export type ErrorBoundaryProps = PropsWithChildren<{
  FallbackComponent?: ComponentType<ErrorFallbackProps>;
  onError?: (error: Error, stackTrace: string) => void;
}>;

type ErrorBoundaryState = { error: Error | null };

/**
 * This is a special case for for using the class components. Error boundaries must be class components because React only provides error boundary functionality through lifecycle methods (componentDidCatch and getDerivedStateFromError) which are not available in functional components.
 * https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary
 */

export class ErrorBoundary extends Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  state: ErrorBoundaryState = { error: null };

  static defaultProps: {
    FallbackComponent: ComponentType<ErrorFallbackProps>;
  } = {
    FallbackComponent: ErrorFallback,
  };

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { error };
  }

  componentDidCatch(error: Error, info: { componentStack: string }): void {
    if (typeof this.props.onError === "function") {
      this.props.onError(error, info.componentStack);
    }
  }

  resetError = (): void => {
    this.setState({ error: null });
  };

  render() {
    const { FallbackComponent } = this.props;

    return this.state.error && FallbackComponent ? (
      <FallbackComponent
        error={this.state.error}
        resetError={this.resetError}
      />
    ) : (
      this.props.children
    );
  }
}

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\components\ErrorFallback.tsx ===
import React, { useState } from "react";
import { reloadAppAsync } from "expo";
import {
  StyleSheet,
  View,
  Pressable,
  ScrollView,
  Text,
  Modal,
  useColorScheme,
  Platform,
} from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { Feather } from "@expo/vector-icons";

export type ErrorFallbackProps = {
  error: Error;
  resetError: () => void;
};

export function ErrorFallback({ error, resetError }: ErrorFallbackProps) {
  const colorScheme = useColorScheme();
  const isDark = colorScheme === "dark";
  const insets = useSafeAreaInsets();

  const theme = {
    background: isDark ? "#000000" : "#FFFFFF",
    backgroundSecondary: isDark ? "#1C1C1E" : "#F2F2F7",
    text: isDark ? "#FFFFFF" : "#000000",
    textSecondary: isDark ? "rgba(255, 255, 255, 0.7)" : "rgba(0, 0, 0, 0.7)",
    link: "#007AFF",
    buttonText: "#FFFFFF",
  };

  const [isModalVisible, setIsModalVisible] = useState(false);

  const handleRestart = async () => {
    try {
      await reloadAppAsync();
    } catch (restartError) {
      console.error("Failed to restart app:", restartError);
      resetError();
    }
  };

  const formatErrorDetails = (): string => {
    let details = `Error: ${error.message}\n\n`;
    if (error.stack) {
      details += `Stack Trace:\n${error.stack}`;
    }
    return details;
  };

  const monoFont = Platform.select({
    ios: "Menlo",
    android: "monospace",
    default: "monospace",
  });

  return (
    <View style={[styles.container, { backgroundColor: theme.background }]}>
      {__DEV__ ? (
        <Pressable
          onPress={() => setIsModalVisible(true)}
          accessibilityLabel="View error details"
          accessibilityRole="button"
          style={({ pressed }) => [
            styles.topButton,
            {
              top: insets.top + 16,
              backgroundColor: theme.backgroundSecondary,
              opacity: pressed ? 0.8 : 1,
            },
          ]}
        >
          <Feather name="alert-circle" size={20} color={theme.text} />
        </Pressable>
      ) : null}

      <View style={styles.content}>
        <Text style={[styles.title, { color: theme.text }]}>
          Something went wrong
        </Text>

        <Text style={[styles.message, { color: theme.textSecondary }]}>
          Please reload the app to continue.
        </Text>

        <Pressable
          onPress={handleRestart}
          style={({ pressed }) => [
            styles.button,
            {
              backgroundColor: theme.link,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.98 : 1 }],
            },
          ]}
        >
          <Text style={[styles.buttonText, { color: theme.buttonText }]}>
            Try Again
          </Text>
        </Pressable>
      </View>

      {__DEV__ ? (
        <Modal
          visible={isModalVisible}
          animationType="slide"
          transparent={true}
          onRequestClose={() => setIsModalVisible(false)}
        >
          <View style={styles.modalOverlay}>
            <View
              style={[
                styles.modalContainer,
                { backgroundColor: theme.background },
              ]}
            >
              <View
                style={[
                  styles.modalHeader,
                  {
                    borderBottomColor: isDark
                      ? "rgba(255, 255, 255, 0.1)"
                      : "rgba(0, 0, 0, 0.1)",
                  },
                ]}
              >
                <Text style={[styles.modalTitle, { color: theme.text }]}>
                  Error Details
                </Text>
                <Pressable
                  onPress={() => setIsModalVisible(false)}
                  accessibilityLabel="Close error details"
                  accessibilityRole="button"
                  style={({ pressed }) => [
                    styles.closeButton,
                    { opacity: pressed ? 0.6 : 1 },
                  ]}
                >
                  <Feather name="x" size={24} color={theme.text} />
                </Pressable>
              </View>

              <ScrollView
                style={styles.modalScrollView}
                contentContainerStyle={[
                  styles.modalScrollContent,
                  { paddingBottom: insets.bottom + 16 },
                ]}
                showsVerticalScrollIndicator
              >
                <View
                  style={[
                    styles.errorContainer,
                    { backgroundColor: theme.backgroundSecondary },
                  ]}
                >
                  <Text
                    style={[
                      styles.errorText,
                      {
                        color: theme.text,
                        fontFamily: monoFont,
                      },
                    ]}
                    selectable
                  >
                    {formatErrorDetails()}
                  </Text>
                </View>
              </ScrollView>
            </View>
          </View>
        </Modal>
      ) : null}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    width: "100%",
    height: "100%",
    justifyContent: "center",
    alignItems: "center",
    padding: 24,
  },
  content: {
    alignItems: "center",
    justifyContent: "center",
    gap: 16,
    width: "100%",
    maxWidth: 600,
  },
  title: {
    fontSize: 28,
    fontWeight: "700",
    textAlign: "center",
    lineHeight: 40,
  },
  message: {
    fontSize: 16,
    textAlign: "center",
    lineHeight: 24,
  },
  topButton: {
    position: "absolute",
    right: 16,
    width: 44,
    height: 44,
    borderRadius: 8,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    zIndex: 10,
  },
  button: {
    paddingVertical: 16,
    borderRadius: 8,
    paddingHorizontal: 24,
    minWidth: 200,
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  buttonText: {
    fontWeight: "600",
    textAlign: "center",
    fontSize: 16,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    justifyContent: "flex-end",
  },
  modalContainer: {
    width: "100%",
    height: "90%",
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
  },
  modalHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 12,
    borderBottomWidth: 1,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: "600",
  },
  closeButton: {
    width: 44,
    height: 44,
    alignItems: "center",
    justifyContent: "center",
  },
  modalScrollView: {
    flex: 1,
  },
  modalScrollContent: {
    padding: 16,
  },
  errorContainer: {
    width: "100%",
    borderRadius: 8,
    overflow: "hidden",
    padding: 16,
  },
  errorText: {
    fontSize: 12,
    lineHeight: 18,
    width: "100%",
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\components\KeyboardAwareScrollViewCompat.tsx ===
// template
import { Platform, ScrollView, ScrollViewProps } from "react-native";
import {
  KeyboardAwareScrollView,
  KeyboardAwareScrollViewProps,
} from "react-native-keyboard-controller";

type Props = KeyboardAwareScrollViewProps & ScrollViewProps;

export function KeyboardAwareScrollViewCompat({
  children,
  keyboardShouldPersistTaps = "handled",
  ...props
}: Props) {
  if (Platform.OS === "web") {
    return (
      <ScrollView keyboardShouldPersistTaps={keyboardShouldPersistTaps} {...props}>
        {children}
      </ScrollView>
    );
  }
  return (
    <KeyboardAwareScrollView
      keyboardShouldPersistTaps={keyboardShouldPersistTaps}
      {...props}
    >
      {children}
    </KeyboardAwareScrollView>
  );
}

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\components\ProUpgradeModal.tsx ===
import React, { useState } from "react";
import { StyleSheet, Text, View, Pressable, Modal, Platform } from "react-native";
import { Ionicons, Feather } from "@expo/vector-icons";
import * as Haptics from "expo-haptics";
import Colors from "@/constants/colors";
import { useI18n } from "@/lib/i18n";

interface ProUpgradeModalProps {
  visible: boolean;
  onClose: () => void;
}

type Plan = "monthly" | "annual";

export default function ProUpgradeModal({ visible, onClose }: ProUpgradeModalProps) {
  const { t } = useI18n();
  const [selectedPlan, setSelectedPlan] = useState<Plan>("annual");
  const pro = (t as any).pro;

  const handleSelect = (plan: Plan) => {
    setSelectedPlan(plan);
    if (Platform.OS !== "web") Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
  };

  const handleContinue = () => {
    if (Platform.OS !== "web") Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    onClose();
  };

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <View style={styles.overlay}>
        <View style={styles.container}>
          <Pressable style={styles.closeButton} onPress={onClose} hitSlop={12}>
            <Feather name="x" size={22} color={Colors.light.textTertiary} />
          </Pressable>

          <View style={styles.iconContainer}>
            <Ionicons name="flash" size={28} color="#fff" />
          </View>

          <Text style={styles.title}>{pro.upgradeTitle}</Text>
          <Text style={styles.subtitle}>{pro.upgradeSubtitle}</Text>

          <View style={styles.featuresCard}>
            <View style={styles.featureRow}>
              <Ionicons name="checkmark" size={18} color={Colors.light.primary} />
              <Text style={styles.featureText}>{pro.feature1}</Text>
            </View>
            <View style={styles.featureRow}>
              <Ionicons name="checkmark" size={18} color={Colors.light.primary} />
              <Text style={styles.featureText}>{pro.feature2}</Text>
            </View>
            <View style={styles.featureRow}>
              <Ionicons name="checkmark" size={18} color={Colors.light.primary} />
              <Text style={styles.featureText}>{pro.feature3}</Text>
            </View>
          </View>

          <Pressable
            style={[styles.planCard, selectedPlan === "monthly" && styles.planCardSelected]}
            onPress={() => handleSelect("monthly")}
          >
            <View style={styles.radioOuter}>
              {selectedPlan === "monthly" && <View style={styles.radioInner} />}
            </View>
            <View style={{ flex: 1 }}>
              <Text style={styles.planName}>{pro.monthly}</Text>
              <Text style={styles.planDesc}>{pro.monthlyDesc}</Text>
            </View>
            <Text style={styles.planPrice}>{pro.monthlyPrice}</Text>
          </Pressable>

          <Pressable
            style={[styles.planCard, selectedPlan === "annual" && styles.planCardSelected]}
            onPress={() => handleSelect("annual")}
          >
            <View style={styles.radioOuter}>
              {selectedPlan === "annual" && <View style={styles.radioInner} />}
            </View>
            <View style={{ flex: 1 }}>
              <View style={styles.planNameRow}>
                <Text style={styles.planName}>{pro.annual}</Text>
                <View style={styles.bestValueBadge}>
                  <Text style={styles.bestValueText}>{pro.annualBadge}</Text>
                </View>
              </View>
              <Text style={styles.planDesc}>{pro.annualDesc}</Text>
            </View>
            <Text style={styles.planPrice}>{pro.annualPrice}</Text>
          </Pressable>

          <Pressable
            style={({ pressed }) => [styles.continueButton, pressed && { opacity: 0.9 }]}
            onPress={handleContinue}
          >
            <Text style={styles.continueText}>{pro.continue}</Text>
          </Pressable>

          <View style={styles.linksRow}>
            <Text style={styles.linkText}>{pro.restorePurchase}</Text>
            <Text style={styles.linkSep}>|</Text>
            <Text style={styles.linkText}>{pro.termsOfUse}</Text>
            <Text style={styles.linkSep}>|</Text>
            <Text style={styles.linkText}>{pro.privacyPolicy}</Text>
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.5)",
    justifyContent: "flex-end",
  },
  container: {
    backgroundColor: Colors.light.surface,
    borderTopLeftRadius: 28,
    borderTopRightRadius: 28,
    paddingHorizontal: 24,
    paddingTop: 20,
    paddingBottom: Platform.OS === "web" ? 34 : 44,
    alignItems: "center",
  },
  closeButton: {
    position: "absolute",
    top: 18,
    right: 18,
    zIndex: 10,
  },
  iconContainer: {
    width: 56,
    height: 56,
    borderRadius: 16,
    backgroundColor: Colors.light.primary,
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 16,
    marginTop: 8,
  },
  title: {
    fontFamily: "Rubik_700Bold",
    fontSize: 22,
    color: Colors.light.text,
    marginBottom: 6,
  },
  subtitle: {
    fontFamily: "Rubik_400Regular",
    fontSize: 14,
    color: Colors.light.textTertiary,
    marginBottom: 20,
  },
  featuresCard: {
    backgroundColor: Colors.light.background,
    borderRadius: 16,
    padding: 18,
    width: "100%",
    gap: 14,
    marginBottom: 20,
  },
  featureRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 10,
  },
  featureText: {
    fontFamily: "Rubik_500Medium",
    fontSize: 15,
    color: Colors.light.text,
  },
  planCard: {
    flexDirection: "row",
    alignItems: "center",
    width: "100%",
    backgroundColor: Colors.light.background,
    borderRadius: 14,
    padding: 18,
    marginBottom: 10,
    borderWidth: 2,
    borderColor: "transparent",
    gap: 14,
  },
  planCardSelected: {
    borderColor: Colors.light.primary,
    backgroundColor: "#FFF7F0",
  },
  radioOuter: {
    width: 22,
    height: 22,
    borderRadius: 11,
    borderWidth: 2,
    borderColor: Colors.light.border,
    alignItems: "center",
    justifyContent: "center",
  },
  radioInner: {
    width: 12,
    height: 12,
    borderRadius: 6,
    backgroundColor: Colors.light.primary,
  },
  planName: {
    fontFamily: "Rubik_600SemiBold",
    fontSize: 16,
    color: Colors.light.text,
  },
  planNameRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
  },
  planDesc: {
    fontFamily: "Rubik_400Regular",
    fontSize: 13,
    color: Colors.light.textTertiary,
    marginTop: 2,
  },
  planPrice: {
    fontFamily: "Rubik_700Bold",
    fontSize: 16,
    color: Colors.light.text,
  },
  bestValueBadge: {
    backgroundColor: Colors.light.primary,
    borderRadius: 6,
    paddingHorizontal: 8,
    paddingVertical: 3,
  },
  bestValueText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 9,
    color: "#fff",
    letterSpacing: 0.5,
  },
  continueButton: {
    backgroundColor: Colors.light.primary,
    width: "100%",
    borderRadius: 16,
    paddingVertical: 18,
    alignItems: "center",
    marginTop: 10,
  },
  continueText: {
    fontFamily: "Rubik_700Bold",
    fontSize: 17,
    color: "#fff",
  },
  linksRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 8,
    marginTop: 16,
  },
  linkText: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.textTertiary,
    textDecorationLine: "underline",
  },
  linkSep: {
    fontFamily: "Rubik_400Regular",
    fontSize: 12,
    color: Colors.light.border,
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\lib\auth-context.tsx ===
import React, { createContext, useContext, useState, useEffect, useMemo, ReactNode, useCallback } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { getApiUrl } from '@/lib/query-client';
import { fetch } from 'expo/fetch';

export interface User {
  id: string;
  email: string;
  username?: string;
}

interface AuthContextValue {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (email: string, password: string) => Promise<{ error?: string }>;
  signup: (email: string, password: string, username?: string) => Promise<{ error?: string; confirmEmail?: boolean }>;
  forgotPassword: (email: string) => Promise<{ error?: string }>;
  logout: () => Promise<void>;
}

const AUTH_TOKEN_KEY = '@rigor_auth_token';
const AUTH_REFRESH_KEY = '@rigor_auth_refresh';
const AUTH_USER_KEY = '@rigor_auth_user';

const AuthContext = createContext<AuthContextValue | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    restoreSession();
  }, []);

  const restoreSession = async () => {
    try {
      const [token, userStr] = await Promise.all([
        AsyncStorage.getItem(AUTH_TOKEN_KEY),
        AsyncStorage.getItem(AUTH_USER_KEY),
      ]);

      if (token && userStr) {
        const baseUrl = getApiUrl();
        const res = await fetch(new URL('/api/auth/me', baseUrl).toString(), {
          headers: { Authorization: `Bearer ${token}` },
          credentials: "include",
        });

        if (res.ok) {
          const data = await res.json();
          setUser(data.user);
        } else {
          const refreshToken = await AsyncStorage.getItem(AUTH_REFRESH_KEY);
          if (refreshToken) {
            const refreshRes = await fetch(new URL('/api/auth/refresh', baseUrl).toString(), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ refresh_token: refreshToken }),
              credentials: "include",
            });
            if (refreshRes.ok) {
              const refreshData = await refreshRes.json();
              if (refreshData.session && refreshData.user) {
                await saveSession(refreshData.session, refreshData.user);
                setUser(refreshData.user);
              } else {
                await clearSession();
              }
            } else {
              await clearSession();
            }
          } else {
            await clearSession();
          }
        }
      }
    } catch (e) {
      console.error('Failed to restore session:', e);
      await clearSession();
    } finally {
      setIsLoading(false);
    }
  };

  const saveSession = async (session: any, userData: User) => {
    await Promise.all([
      AsyncStorage.setItem(AUTH_TOKEN_KEY, session.access_token),
      AsyncStorage.setItem(AUTH_REFRESH_KEY, session.refresh_token),
      AsyncStorage.setItem(AUTH_USER_KEY, JSON.stringify(userData)),
    ]);
  };

  const clearSession = async () => {
    await Promise.all([
      AsyncStorage.removeItem(AUTH_TOKEN_KEY),
      AsyncStorage.removeItem(AUTH_REFRESH_KEY),
      AsyncStorage.removeItem(AUTH_USER_KEY),
    ]);
    setUser(null);
  };

  const login = useCallback(async (email: string, password: string): Promise<{ error?: string }> => {
    try {
      const baseUrl = getApiUrl();
      const res = await fetch(new URL('/api/auth/login', baseUrl).toString(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
        credentials: "include",
      });
      const data = await res.json();
      if (!res.ok) return { error: data.error || 'Login failed' };

      await saveSession(data.session, data.user);
      setUser(data.user);
      return {};
    } catch (e: any) {
      return { error: e.message || 'Connection error' };
    }
  }, []);

  const signup = useCallback(async (email: string, password: string, username?: string): Promise<{ error?: string; confirmEmail?: boolean }> => {
    try {
      const baseUrl = getApiUrl();
      const res = await fetch(new URL('/api/auth/signup', baseUrl).toString(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password, username }),
        credentials: "include",
      });
      const data = await res.json();
      if (!res.ok) return { error: data.error || 'Signup failed' };

      if (data.session && data.user) {
        await saveSession(data.session, data.user);
        setUser(data.user);
        return {};
      }

      return { confirmEmail: true };
    } catch (e: any) {
      return { error: e.message || 'Connection error' };
    }
  }, []);

  const forgotPassword = useCallback(async (email: string): Promise<{ error?: string }> => {
    try {
      const baseUrl = getApiUrl();
      const res = await fetch(new URL('/api/auth/forgot-password', baseUrl).toString(), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email }),
        credentials: "include",
      });
      const data = await res.json();
      if (!res.ok) return { error: data.error || 'Failed to send reset email' };
      return {};
    } catch (e: any) {
      return { error: e.message || 'Connection error' };
    }
  }, []);

  const logout = useCallback(async () => {
    try {
      const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);
      if (token) {
        const baseUrl = getApiUrl();
        await fetch(new URL('/api/auth/logout', baseUrl).toString(), {
          method: 'POST',
          headers: { Authorization: `Bearer ${token}` },
          credentials: "include",
        });
      }
    } catch (e) {}
    await clearSession();
  }, []);

  const value = useMemo(() => ({
    user,
    isAuthenticated: !!user,
    isLoading,
    login,
    signup,
    forgotPassword,
    logout,
  }), [user, isLoading, login, signup, forgotPassword, logout]);

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\lib\i18n.tsx ===
import React, { createContext, useContext, useState, useEffect, useMemo, ReactNode, useCallback } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';

export type Language = 'en' | 'pt';

const LANGUAGE_KEY = '@rigor_language';

const translations = {
  en: {
    tabs: {
      today: 'Today',
      progress: 'Progress',
      squads: 'Squads',
      trophies: 'Trophies',
      profile: 'Profile',
    },
    today: {
      noContract: 'No active contract',
      noContractDesc: 'Sign your first contract to begin.',
      signFirst: 'Sign my first contract',
      day: 'DAY',
      completed: 'COMPLETED',
      failed: 'FAILED',
      before: 'before',
      remaining: 'remaining',
      streak: 'Streak',
      noReturn: 'No return',
      dayCompleted: 'Day completed',
      done: 'Done',
      newDay: 'New Day!',
      newDayQuestion: 'Did you complete your mission yesterday?',
      yesCompleted: 'Yes, I completed it!',
      noFailed: 'No, I failed...',
      beHonest: 'Be honest! Your progress depends on it.',
    },
    progress: {
      title: 'Progress',
      active: 'active',
      rate: 'RATE',
      done: 'DONE',
      fails: 'FAILS',
      consistencyMap: 'CONSISTENCY MAP',
      legendDone: 'Done',
      legendFail: 'Fail',
      legendCritical: 'Critical',
      insights: 'INSIGHTS',
      bestStreak: 'Best streak',
      currentStreak: 'Current streak',
      day: 'day',
      days: 'days',
    },
    squads: {
      title: 'Squads',
      create: 'Create',
      join: 'Join',
      noSquads: 'No squads yet',
      noSquadsDesc: 'Create or join a squad for social accountability.',
      code: 'Code',
      createSquad: 'Create Squad',
      squadName: 'SQUAD NAME',
      squadNamePlaceholder: 'E.g.: Total Discipline',
      joinSquad: 'Join Squad',
      squadCode: 'SQUAD CODE',
      squadCodePlaceholder: 'E.g.: a1b2c3d4',
      back: 'Back',
      codeLabel: 'CODE',
      ranking: 'RANKING',
      noMembers: 'No members found',
      days: 'days',
      failures: 'failures',
      leaveSquad: 'Leave squad',
      leaveTitle: 'Leave Squad',
      leaveMessage: 'Leave "{name}"? This cannot be undone.',
      cancel: 'Cancel',
      leave: 'Leave',
      errorInvalidCode: 'Invalid code or you are already a member of this squad.',
    },
    trophies: {
      title: 'Achievements',
      daysCompleted: 'days completed',
      achievements: {
        firstStep: 'First Step',
        firstStepDesc: 'Complete your first day',
        solidStart: 'Solid Start',
        solidStartDesc: 'Complete 3 consecutive days',
        steadyHand: 'Steady Hand',
        steadyHandDesc: 'Complete 5 days',
        weekWarrior: 'Week Warrior',
        weekWarriorDesc: 'Complete 7 days',
        doubleDigits: 'Double Digits',
        doubleDigitsDesc: 'Complete 10 days',
        twoWeeks: 'Two Weeks',
        twoWeeksDesc: 'Complete 14 days',
        habit21: '21-Day Habit',
        habit21Desc: 'Complete 21 days',
        monthMaster: 'Month Master',
        monthMasterDesc: 'Complete 30 days',
        halfwayThere: 'Halfway There',
        halfwayThereDesc: 'Complete 33 days',
        ironWill: 'Iron Will',
        ironWillDesc: 'Complete 40 days',
        unstoppable: 'Unstoppable',
        unstoppableDesc: 'Complete 50 days',
        diamondHands: 'Diamond Hands',
        diamondHandsDesc: 'Complete 60 days',
        trueDiscipline: 'True Discipline',
        trueDisciplineDesc: 'Complete 66 days',
        zeroFails: 'Zero Fails',
        zeroFailsDesc: 'Complete contract with 0 fails',
        legend: 'Legend',
        legendDesc: 'Complete 3 contracts',
      },
    },
    profile: {
      title: 'Profile',
      active: 'Active',
      activeContract: 'Active Contract',
      rule: 'Rule',
      duration: 'Duration',
      deadline: 'Deadline',
      startDate: 'Start Date',
      remaining: 'Remaining',
      days: 'days',
      statistics: 'STATISTICS',
      completed: 'Completed',
      failed: 'Failed',
      rate: 'Rate',
      streak: 'Streak',
      bestStreak: 'Best streak',
      day: 'day',
      settings: 'SETTINGS',
      dailyReminder: 'Daily Reminder',
      language: 'Language',
      difficulty: 'Difficulty',
      aboutRigor: 'About RIGOR',
      signOut: 'Sign Out',
      signOutConfirm: 'Are you sure you want to sign out?',
      resetAll: 'Reset all data',
      resetTitle: 'Reset Everything',
      resetMessage: 'This will delete your contract, all records, and squads. This cannot be undone.',
      reset: 'Reset',
      cancel: 'Cancel',
      resetProgress: 'Reset progress',
      resetProgressFree: '1 free reset available',
      resetProgressUsed: 'Free reset used',
      resetProgressPro: 'Unlimited resets',
      resetProgressTitle: 'Reset Progress',
      resetProgressMessage: 'This will delete all your contracts and daily records. Your squads will be kept. This cannot be undone.',
      resetProgressConfirm: 'Reset Progress',
      noResetsLeft: 'No free resets left. Upgrade to PRO for unlimited resets.',
      permissionNeeded: 'Permission needed',
      permissionMessage: 'Enable notifications in your device settings to receive reminders.',
      english: 'English',
      portuguese: 'Portuguese',
      languageTitle: 'Language',
      difficultyTitle: 'Difficulty',
      difficultyWarning: 'Warning: this will replace your current missions.',
      medium: 'Medium',
      hard: 'Hard',
      extreme: 'Extreme',
      mission: 'mission',
      missions: 'missions',
      pro: 'PRO',
    },
    createContract: {
      title: 'New Contract',
      step1Title: 'Define your rule',
      step1Desc: 'A specific action you commit to every day. One rule. No negotiation.',
      inputPlaceholder: 'e.g., "Workout", "Study for 1 hour"',
      next: 'Next',
      step2Title: 'Set the deadline',
      step2Desc: 'The time limit to complete it each day. Missed the deadline? Failure recorded.',
      deadlineNote: 'Every 7 consecutive days, your deadline shrinks by 30 min.',
      step3Title: 'Choose duration',
      step3Desc: 'Once signed, it can\'t be edited, paused, or cancelled. The contract is irreversible.',
      days: 'days',
      contractSummary: 'Contract Summary',
      rule: 'Rule',
      deadline: 'Deadline',
      duration: 'Duration',
      warning: 'No editing. No pausing. No excuses. This is irreversible.',
      signContract: 'Sign Contract',
    },
    shareCard: {
      title: 'Share',
      day: 'DAY',
      consistencyMap: 'CONSISTENCY MAP',
      completed: 'Completed',
      failed: 'Failed',
      critical: 'Critical',
      rate: 'Rate',
      contract: 'Contract',
      download: 'Download image',
      hint: 'PNG · Instagram ready',
    },
    pro: {
      upgradeTitle: 'Upgrade to Pro',
      upgradeSubtitle: 'Unlock the full RIGOR experience',
      feature1: 'Unlimited missions & challenges',
      feature2: 'Unlimited progress resets',
      feature3: 'Hard & Extreme difficulty modes',
      monthly: 'Monthly',
      monthlyDesc: 'Cancel anytime',
      monthlyPrice: '$4.99/month',
      annual: 'Annual',
      annualBadge: 'BEST VALUE',
      annualDesc: 'Save 50%',
      annualPrice: '$29/year',
      continue: 'Continue',
      restorePurchase: 'Restore Purchase',
      termsOfUse: 'Terms of Use',
      privacyPolicy: 'Privacy Policy',
    },
    about: {
      title: 'About',
      version: 'Version 1.0.0',
      description: 'RIGOR is a discipline tracking app built on commitment. Create irreversible contracts with yourself, track your daily consistency, and build unbreakable habits.',
      irreversibleContracts: 'Irreversible Contracts',
      irreversibleContractsDesc: 'Once signed, no editing, no pausing, no excuses',
      consistencyHeatmap: 'Consistency Heatmap',
      consistencyHeatmapDesc: 'Visualize your discipline over time',
      squads: 'Squads',
      squadsDesc: 'Accountability groups to keep you honest',
      trophies: 'Trophies',
      trophiesDesc: 'Earn achievements for your dedication',
      shrinkingDeadlines: 'Shrinking Deadlines',
      shrinkingDeadlinesDesc: 'Every 7-day streak cuts 30 min from your deadline',
      footer: 'Built with discipline, for the disciplined.',
    },
    auth: {
      login: 'Sign In',
      loginTitle: 'Welcome back',
      loginSubtitle: 'Sign in to continue',
      signup: 'Sign Up',
      signupTitle: 'Create Account',
      signupSubtitle: 'Start your discipline journey',
      email: 'Email',
      username: 'Username',
      usernamePlaceholder: 'e.g. john_doe',
      password: 'Password',
      forgotPassword: 'Forgot password?',
      noAccount: "Don't have an account?",
      haveAccount: 'Already have an account?',
      forgotTitle: 'Forgot Password',
      forgotSubtitle: 'Enter your email to reset your password',
      sendReset: 'Send Reset Link',
      backToLogin: 'Back to Sign In',
    },
  },
  pt: {
    tabs: {
      today: 'Hoje',
      progress: 'Progresso',
      squads: 'Squads',
      trophies: 'Troféus',
      profile: 'Perfil',
    },
    today: {
      noContract: 'Nenhum contrato ativo',
      noContractDesc: 'Assine seu primeiro contrato para começar.',
      signFirst: 'Assinar meu primeiro contrato',
      day: 'DIA',
      completed: 'CUMPRIDOS',
      failed: 'FALHAS',
      before: 'antes das',
      remaining: 'restantes',
      streak: 'Sequência',
      noReturn: 'Sem volta',
      dayCompleted: 'Dia concluído',
      done: 'Concluir',
      newDay: 'Novo Dia!',
      newDayQuestion: 'Você completou sua missão ontem?',
      yesCompleted: 'Sim, eu completei!',
      noFailed: 'Não, eu falhei...',
      beHonest: 'Seja honesto! Seu progresso depende disso.',
    },
    progress: {
      title: 'Progresso',
      active: 'ativo',
      rate: 'TAXA',
      done: 'FEITOS',
      fails: 'FALHAS',
      consistencyMap: 'MAPA DE CONSISTÊNCIA',
      legendDone: 'Cumprido',
      legendFail: 'Falha',
      legendCritical: 'Crítica',
      insights: 'INSIGHTS',
      bestStreak: 'Melhor sequência',
      currentStreak: 'Sequência atual',
      day: 'dia',
      days: 'dias',
    },
    squads: {
      title: 'Squads',
      create: 'Criar',
      join: 'Entrar',
      noSquads: 'Nenhum squad ainda',
      noSquadsDesc: 'Crie ou entre em um squad para ter responsabilidade social.',
      code: 'Código',
      createSquad: 'Criar Squad',
      squadName: 'NOME DO SQUAD',
      squadNamePlaceholder: 'Ex: Disciplina Total',
      joinSquad: 'Entrar no Squad',
      squadCode: 'CÓDIGO DO SQUAD',
      squadCodePlaceholder: 'Ex: a1b2c3d4',
      back: 'Voltar',
      codeLabel: 'CÓDIGO',
      ranking: 'RANKING',
      noMembers: 'Nenhum membro encontrado',
      days: 'dias',
      failures: 'falhas',
      leaveSquad: 'Sair do squad',
      leaveTitle: 'Sair do Squad',
      leaveMessage: 'Sair de "{name}"? Isso não pode ser desfeito.',
      cancel: 'Cancelar',
      leave: 'Sair',
      errorInvalidCode: 'Código inválido ou você já faz parte deste squad.',
    },
    trophies: {
      title: 'Conquistas',
      daysCompleted: 'dias cumpridos',
      achievements: {
        firstStep: 'Primeiro Passo',
        firstStepDesc: 'Complete seu primeiro dia',
        solidStart: 'Começo Sólido',
        solidStartDesc: 'Complete 3 dias consecutivos',
        steadyHand: 'Mão Firme',
        steadyHandDesc: 'Complete 5 dias',
        weekWarrior: 'Guerreiro da Semana',
        weekWarriorDesc: 'Complete 7 dias',
        doubleDigits: 'Dígitos Duplos',
        doubleDigitsDesc: 'Complete 10 dias',
        twoWeeks: 'Duas Semanas',
        twoWeeksDesc: 'Complete 14 dias',
        habit21: 'Hábito de 21 Dias',
        habit21Desc: 'Complete 21 dias',
        monthMaster: 'Mestre do Mês',
        monthMasterDesc: 'Complete 30 dias',
        halfwayThere: 'Metade do Caminho',
        halfwayThereDesc: 'Complete 33 dias',
        ironWill: 'Vontade de Ferro',
        ironWillDesc: 'Complete 40 dias',
        unstoppable: 'Imparável',
        unstoppableDesc: 'Complete 50 dias',
        diamondHands: 'Mãos de Diamante',
        diamondHandsDesc: 'Complete 60 dias',
        trueDiscipline: 'Disciplina Verdadeira',
        trueDisciplineDesc: 'Complete 66 dias',
        zeroFails: 'Zero Falhas',
        zeroFailsDesc: 'Complete contrato com 0 falhas',
        legend: 'Lenda',
        legendDesc: 'Complete 3 contratos',
      },
    },
    profile: {
      title: 'Perfil',
      active: 'Ativo',
      activeContract: 'Contrato Ativo',
      rule: 'Regra',
      duration: 'Duração',
      deadline: 'Prazo',
      startDate: 'Data de Início',
      remaining: 'Restante',
      days: 'dias',
      statistics: 'ESTATÍSTICAS',
      completed: 'Cumpridos',
      failed: 'Falhas',
      rate: 'Taxa',
      streak: 'Sequência',
      bestStreak: 'Melhor sequência',
      day: 'dia',
      settings: 'CONFIGURAÇÕES',
      dailyReminder: 'Lembrete Diário',
      language: 'Idioma',
      difficulty: 'Dificuldade',
      aboutRigor: 'Sobre o RIGOR',
      signOut: 'Sair',
      signOutConfirm: 'Tem certeza que deseja sair?',
      resetAll: 'Resetar todos os dados',
      resetTitle: 'Resetar Tudo',
      resetMessage: 'Isso irá deletar seu contrato, todos os registros e squads. Isso não pode ser desfeito.',
      reset: 'Resetar',
      cancel: 'Cancelar',
      resetProgress: 'Resetar progresso',
      resetProgressFree: '1 reset gratuito disponível',
      resetProgressUsed: 'Reset gratuito utilizado',
      resetProgressPro: 'Resets ilimitados',
      resetProgressTitle: 'Resetar Progresso',
      resetProgressMessage: 'Isso irá deletar todos os seus contratos e registros diários. Seus squads serão mantidos. Isso não pode ser desfeito.',
      resetProgressConfirm: 'Resetar Progresso',
      noResetsLeft: 'Sem resets gratuitos. Atualize para PRO para resets ilimitados.',
      permissionNeeded: 'Permissão necessária',
      permissionMessage: 'Ative as notificações nas configurações do dispositivo para receber lembretes.',
      english: 'English',
      portuguese: 'Português',
      languageTitle: 'Idioma',
      difficultyTitle: 'Dificuldade',
      difficultyWarning: 'Aviso: isso substituirá suas missões atuais.',
      medium: 'Medium',
      hard: 'Hard',
      extreme: 'Extreme',
      mission: 'missão',
      missions: 'missões',
      pro: 'PRO',
    },
    createContract: {
      title: 'Novo Contrato',
      step1Title: 'Defina sua regra',
      step1Desc: 'Uma ação específica que você se compromete a fazer todos os dias. Uma regra. Sem negociação.',
      inputPlaceholder: 'Ex: "Treinar", "Estudar 1 hora"',
      next: 'Próximo',
      step2Title: 'Defina o prazo',
      step2Desc: 'O limite de tempo para cumprir a cada dia. Perdeu o prazo? Falha registrada.',
      deadlineNote: 'A cada 7 dias consecutivos, seu prazo diminui em 30 min.',
      step3Title: 'Escolha a duração',
      step3Desc: 'Depois de assinado, não pode ser editado, pausado ou cancelado. O contrato é irreversível.',
      days: 'dias',
      contractSummary: 'Resumo do Contrato',
      rule: 'Regra',
      deadline: 'Prazo',
      duration: 'Duração',
      warning: 'Sem edição. Sem pausa. Sem desculpas. Isso é irreversível.',
      signContract: 'Assinar Contrato',
    },
    shareCard: {
      title: 'Compartilhar',
      day: 'DIA',
      consistencyMap: 'MAPA DE CONSISTÊNCIA',
      completed: 'Cumprido',
      failed: 'Falha',
      critical: 'Crítica',
      rate: 'Taxa',
      contract: 'Contrato',
      download: 'Baixar imagem',
      hint: 'PNG · Pronto para Instagram',
    },
    pro: {
      upgradeTitle: 'Upgrade to Pro',
      upgradeSubtitle: 'Desbloqueie a experiência RIGOR completa',
      feature1: 'Missões e desafios ilimitados',
      feature2: 'Resets de progresso ilimitados',
      feature3: 'Modos de dificuldade Hard e Extreme',
      monthly: 'Mensal',
      monthlyDesc: 'Cancele quando quiser',
      monthlyPrice: '$4,99/mês',
      annual: 'Anual',
      annualBadge: 'MELHOR VALOR',
      annualDesc: 'Economize 50%',
      annualPrice: '$29/ano',
      continue: 'Continuar',
      restorePurchase: 'Restaurar Compra',
      termsOfUse: 'Termos de Uso',
      privacyPolicy: 'Política de Privacidade',
    },
    about: {
      title: 'Sobre',
      version: 'Versão 1.0.0',
      description: 'RIGOR é um app de rastreamento de disciplina baseado em compromisso. Crie contratos irreversíveis consigo mesmo, acompanhe sua consistência diária e construa hábitos inquebráveis.',
      irreversibleContracts: 'Contratos Irreversíveis',
      irreversibleContractsDesc: 'Uma vez assinado, sem edição, sem pausa, sem desculpas',
      consistencyHeatmap: 'Mapa de Consistência',
      consistencyHeatmapDesc: 'Visualize sua disciplina ao longo do tempo',
      squads: 'Squads',
      squadsDesc: 'Grupos de responsabilidade para te manter honesto',
      trophies: 'Troféus',
      trophiesDesc: 'Ganhe conquistas pela sua dedicação',
      shrinkingDeadlines: 'Prazos Reduzidos',
      shrinkingDeadlinesDesc: 'A cada sequência de 7 dias, 30 min são cortados do seu prazo',
      footer: 'Construído com disciplina, para os disciplinados.',
    },
    auth: {
      login: 'Entrar',
      loginTitle: 'Bem-vindo de volta',
      loginSubtitle: 'Entre para continuar',
      signup: 'Criar Conta',
      signupTitle: 'Criar Conta',
      signupSubtitle: 'Comece sua jornada de disciplina',
      email: 'Email',
      username: 'Nome de usuário',
      usernamePlaceholder: 'Ex: joao_silva',
      password: 'Senha',
      forgotPassword: 'Esqueceu a senha?',
      noAccount: 'Não tem uma conta?',
      haveAccount: 'Já tem uma conta?',
      forgotTitle: 'Esqueceu a Senha',
      forgotSubtitle: 'Digite seu email para resetar sua senha',
      sendReset: 'Enviar Link de Reset',
      backToLogin: 'Voltar para Login',
    },
  },
} as const;

type Translations = typeof translations['en'];

interface I18nContextValue {
  language: Language;
  setLanguage: (lang: Language) => Promise<void>;
  t: Translations;
}

const I18nContext = createContext<I18nContextValue | null>(null);

export function I18nProvider({ children }: { children: ReactNode }) {
  const [language, setLanguageState] = useState<Language>('en');
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    AsyncStorage.getItem(LANGUAGE_KEY).then((val) => {
      if (val === 'pt' || val === 'en') setLanguageState(val);
      setLoaded(true);
    }).catch(() => setLoaded(true));
  }, []);

  const setLanguage = useCallback(async (lang: Language) => {
    setLanguageState(lang);
    await AsyncStorage.setItem(LANGUAGE_KEY, lang);
  }, []);

  const t = translations[language];

  const value = useMemo(() => ({
    language,
    setLanguage,
    t,
  }), [language, setLanguage, t]);

  if (!loaded) return null;

  return (
    <I18nContext.Provider value={value}>
      {children}
    </I18nContext.Provider>
  );
}

export function useI18n() {
  const context = useContext(I18nContext);
  if (!context) {
    throw new Error('useI18n must be used within an I18nProvider');
  }
  return context;
}

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\lib\query-client.ts ===
import { fetch } from "expo/fetch";
import { QueryClient, QueryFunction } from "@tanstack/react-query";
import AsyncStorage from "@react-native-async-storage/async-storage";

const AUTH_TOKEN_KEY = '@rigor_auth_token';

export function getApiUrl(): string {
  // Full URL takes precedence (e.g. https://api.example.com)
  const apiUrl = process.env.EXPO_PUBLIC_API_URL;
  if (apiUrl) {
    return apiUrl.replace(/\/$/, "");
  }

  const host = process.env.EXPO_PUBLIC_DOMAIN;
  if (!host) {
    throw new Error("EXPO_PUBLIC_DOMAIN or EXPO_PUBLIC_API_URL must be set");
  }

  // Use http for local development (localhost / 127.0.0.1)
  const isLocal =
    host.startsWith("localhost") || host.startsWith("127.0.0.1");
  const protocol = isLocal ? "http" : "https";
  const url = new URL(`${protocol}://${host}`);
  return url.href.replace(/\/$/, "");
}

async function getAuthHeaders(): Promise<Record<string, string>> {
  try {
    const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);
    if (token) return { Authorization: `Bearer ${token}` };
  } catch {}
  return {};
}

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest(
  method: string,
  route: string,
  data?: unknown | undefined,
): Promise<Response> {
  const baseUrl = getApiUrl();
  const url = new URL(route, baseUrl);
  const authHeaders = await getAuthHeaders();

  const res = await fetch(url.toString(), {
    method,
    headers: {
      ...authHeaders,
      ...(data ? { "Content-Type": "application/json" } : {}),
    },
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const baseUrl = getApiUrl();
    const url = new URL(queryKey.join("/") as string, baseUrl);
    const authHeaders = await getAuthHeaders();

    const res = await fetch(url.toString(), {
      headers: authHeaders,
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\lib\rigor-context.tsx ===
import React, { createContext, useContext, useState, useEffect, useMemo, ReactNode, useCallback } from 'react';
import { apiRequest, getApiUrl } from '@/lib/query-client';
import { useAuth } from '@/lib/auth-context';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { fetch } from 'expo/fetch';

export interface Contract {
  id: string;
  rule: string;
  deadline_hour: number;
  deadline_minute: number;
  duration: number;
  start_date: string;
  signed: boolean;
}

export interface DayRecord {
  id?: string;
  date: string;
  completed: boolean;
  failed: boolean;
  critical: boolean;
  justification?: string;
}

export interface Squad {
  id: string;
  name: string;
  code: string;
  created_at: string;
}

interface RigorContextValue {
  contract: Contract | null;
  dayRecords: DayRecord[];
  squads: Squad[];
  isLoading: boolean;
  signContract: (rule: string, deadlineHour: number, deadlineMinute: number, duration: number) => Promise<void>;
  markDone: () => Promise<void>;
  createSquad: (name: string) => Promise<void>;
  joinSquad: (code: string) => Promise<boolean>;
  leaveSquad: (id: string) => Promise<void>;
  getDayNumber: () => number;
  getCompletedCount: () => number;
  getFailedCount: () => number;
  getCurrentStreak: () => number;
  getBestStreak: () => number;
  getCompletionRate: () => number;
  getDaysRemaining: () => number;
  getCurrentDeadline: () => { hour: number; minute: number };
  isTodayCompleted: () => boolean;
  isTodayFailed: () => boolean;
  getTodayRecord: () => DayRecord | undefined;
  resetAll: () => Promise<void>;
  resetProgress: () => Promise<boolean>;
  refreshData: () => Promise<void>;
}

const AUTH_TOKEN_KEY = '@rigor_auth_token';

const RigorContext = createContext<RigorContextValue | null>(null);

function generateCode(): string {
  const chars = '0123456789abcdef';
  let result = '';
  for (let i = 0; i < 8; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

function getDateStr(date: Date = new Date()): string {
  return date.toISOString().split('T')[0];
}

function daysBetween(start: string, end: string): number {
  const s = new Date(start + 'T00:00:00');
  const e = new Date(end + 'T00:00:00');
  return Math.floor((e.getTime() - s.getTime()) / (1000 * 60 * 60 * 24));
}

export function RigorProvider({ children }: { children: ReactNode }) {
  const { user, isAuthenticated } = useAuth();
  const [contract, setContract] = useState<Contract | null>(null);
  const [dayRecords, setDayRecords] = useState<DayRecord[]>([]);
  const [squads, setSquads] = useState<Squad[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (isAuthenticated && user) {
      loadAllData();
    } else {
      setContract(null);
      setDayRecords([]);
      setSquads([]);
    }
  }, [isAuthenticated, user?.id]);

  const getAuthHeader = async (): Promise<Record<string, string>> => {
    try {
      const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);
      if (token) return { Authorization: `Bearer ${token}` };
    } catch {}
    return {};
  };

  const loadAllData = async () => {
    setIsLoading(true);
    try {
      const baseUrl = getApiUrl();
      const authHeaders = await getAuthHeader();

      const [contractRes, recordsRes, squadsRes] = await Promise.all([
        fetch(new URL('/api/contract', baseUrl).toString(), { headers: authHeaders }),
        fetch(new URL('/api/records', baseUrl).toString(), { headers: authHeaders }),
        fetch(new URL('/api/squads', baseUrl).toString(), { headers: authHeaders }),
      ]);

      if (contractRes.ok) {
        const contractData = await contractRes.json();
        setContract(contractData.contract || null);
      }

      if (recordsRes.ok) {
        const recordsData = await recordsRes.json();
        setDayRecords(recordsData.records || []);
      }

      if (squadsRes.ok) {
        const squadsData = await squadsRes.json();
        setSquads(squadsData.squads || []);
      }
    } catch (e) {
      console.error('Failed to load data:', e);
    } finally {
      setIsLoading(false);
    }
  };

  const refreshData = useCallback(async () => {
    if (isAuthenticated) await loadAllData();
  }, [isAuthenticated]);

  const signContract = useCallback(async (rule: string, deadlineHour: number, deadlineMinute: number, duration: number) => {
    if (!isAuthenticated) return;
    try {
      const res = await apiRequest('POST', '/api/contract', {
        rule,
        deadline_hour: deadlineHour,
        deadline_minute: deadlineMinute,
        duration,
        start_date: getDateStr(),
      });
      const data = await res.json();
      setContract(data.contract);
      setDayRecords([]);
    } catch (e) {
      console.error('Failed to sign contract:', e);
    }
  }, [isAuthenticated]);

  const markDone = useCallback(async () => {
    if (!isAuthenticated || !contract) return;
    const today = getDateStr();
    try {
      const res = await apiRequest('POST', '/api/records', {
        contract_id: contract.id,
        date: today,
        completed: true,
        failed: false,
        critical: false,
      });
      const data = await res.json();
      setDayRecords(prev => {
        const filtered = prev.filter(r => r.date !== today);
        return [...filtered, data.record];
      });
    } catch (e) {
      console.error('Failed to mark done:', e);
    }
  }, [isAuthenticated, contract]);

  const createSquad = useCallback(async (name: string) => {
    if (!isAuthenticated) return;
    try {
      const code = generateCode();
      const res = await apiRequest('POST', '/api/squads', { name, code });
      const data = await res.json();
      setSquads(prev => [...prev, data.squad]);
    } catch (e) {
      console.error('Failed to create squad:', e);
    }
  }, [isAuthenticated]);

  const joinSquad = useCallback(async (code: string): Promise<boolean> => {
    if (!isAuthenticated) return false;
    try {
      const res = await apiRequest('POST', '/api/squads/join', { code });
      const data = await res.json();
      setSquads(prev => [...prev, data.squad]);
      return true;
    } catch (e) {
      return false;
    }
  }, [isAuthenticated]);

  const leaveSquad = useCallback(async (id: string) => {
    if (!isAuthenticated) return;
    try {
      await apiRequest('DELETE', `/api/squads/${id}`);
      setSquads(prev => prev.filter(s => s.id !== id));
    } catch (e) {
      console.error('Failed to leave squad:', e);
    }
  }, [isAuthenticated]);

  const getDayNumber = useCallback((): number => {
    if (!contract) return 0;
    const today = getDateStr();
    return daysBetween(contract.start_date, today) + 1;
  }, [contract]);

  const getCompletedCount = useCallback((): number => {
    return dayRecords.filter(r => r.completed).length;
  }, [dayRecords]);

  const getFailedCount = useCallback((): number => {
    return dayRecords.filter(r => r.failed).length;
  }, [dayRecords]);

  const getCurrentStreak = useCallback((): number => {
    if (!contract) return 0;
    let streak = 0;
    const today = getDateStr();
    const sorted = [...dayRecords]
      .filter(r => r.completed)
      .sort((a, b) => b.date.localeCompare(a.date));

    for (const record of sorted) {
      const d = new Date(today + 'T00:00:00');
      d.setDate(d.getDate() - streak);
      if (getDateStr(d) === record.date) {
        streak++;
      } else {
        break;
      }
    }
    return streak;
  }, [contract, dayRecords]);

  const getBestStreak = useCallback((): number => {
    if (!contract || dayRecords.length === 0) return 0;
    const sorted = [...dayRecords].sort((a, b) => a.date.localeCompare(b.date));
    let best = 0;
    let current = 0;

    for (let i = 0; i < sorted.length; i++) {
      if (sorted[i].completed) {
        current++;
        if (current > best) best = current;
      } else {
        current = 0;
      }
    }
    return best;
  }, [contract, dayRecords]);

  const getCompletionRate = useCallback((): number => {
    const total = dayRecords.length;
    if (total === 0) return 0;
    const completed = dayRecords.filter(r => r.completed).length;
    return Math.round((completed / total) * 100);
  }, [dayRecords]);

  const getDaysRemaining = useCallback((): number => {
    if (!contract) return 0;
    return Math.max(0, contract.duration - getDayNumber());
  }, [contract, getDayNumber]);

  const getCurrentDeadline = useCallback((): { hour: number; minute: number } => {
    if (!contract) return { hour: 23, minute: 0 };
    const streak = getCurrentStreak();
    const reductions = Math.floor(streak / 7);
    let totalMinutes = contract.deadline_hour * 60 + contract.deadline_minute;
    totalMinutes -= reductions * 30;
    if (totalMinutes < 0) totalMinutes = 0;
    return {
      hour: Math.floor(totalMinutes / 60),
      minute: totalMinutes % 60,
    };
  }, [contract, getCurrentStreak]);

  const isTodayCompleted = useCallback((): boolean => {
    const today = getDateStr();
    return dayRecords.some(r => r.date === today && r.completed);
  }, [dayRecords]);

  const isTodayFailed = useCallback((): boolean => {
    const today = getDateStr();
    return dayRecords.some(r => r.date === today && r.failed);
  }, [dayRecords]);

  const getTodayRecord = useCallback((): DayRecord | undefined => {
    const today = getDateStr();
    return dayRecords.find(r => r.date === today);
  }, [dayRecords]);

  const resetAll = useCallback(async () => {
    if (!isAuthenticated) return;
    try {
      await apiRequest('DELETE', '/api/reset');
      setContract(null);
      setDayRecords([]);
      setSquads([]);
    } catch (e) {
      console.error('Failed to reset:', e);
    }
  }, [isAuthenticated]);

  const resetProgress = useCallback(async (): Promise<boolean> => {
    if (!isAuthenticated) return false;
    try {
      await apiRequest('DELETE', '/api/reset-progress');
      setContract(null);
      setDayRecords([]);
      return true;
    } catch (e) {
      console.error('Failed to reset progress:', e);
      return false;
    }
  }, [isAuthenticated]);

  const value = useMemo(() => ({
    contract,
    dayRecords,
    squads,
    isLoading,
    signContract,
    markDone,
    createSquad,
    joinSquad,
    leaveSquad,
    getDayNumber,
    getCompletedCount,
    getFailedCount,
    getCurrentStreak,
    getBestStreak,
    getCompletionRate,
    getDaysRemaining,
    getCurrentDeadline,
    isTodayCompleted,
    isTodayFailed,
    getTodayRecord,
    resetAll,
    resetProgress,
    refreshData,
  }), [contract, dayRecords, squads, isLoading, signContract, markDone, createSquad, joinSquad, leaveSquad, getDayNumber, getCompletedCount, getFailedCount, getCurrentStreak, getBestStreak, getCompletionRate, getDaysRemaining, getCurrentDeadline, isTodayCompleted, isTodayFailed, getTodayRecord, resetAll, resetProgress, refreshData]);

  return (
    <RigorContext.Provider value={value}>
      {children}
    </RigorContext.Provider>
  );
}

export function useRigor() {
  const context = useContext(RigorContext);
  if (!context) {
    throw new Error('useRigor must be used within a RigorProvider');
  }
  return context;
}

=== C:\Users\Pichau\Desktop\RIGOR APP\RIGOR APP\constants\colors.ts ===
const orange = "#E8611A";
const orangeLight = "#F5A623";
const black = "#1A1A1A";
const darkGray = "#4A4A4A";
const mediumGray = "#8E8E8E";
const lightGray = "#D4D4D4";
const paleGray = "#ECECEC";
const cream = "#FAF8F5";
const white = "#FFFFFF";
const red = "#E53935";
const green = "#43A047";

export default {
  light: {
    primary: orange,
    primaryLight: orangeLight,
    text: black,
    textSecondary: darkGray,
    textTertiary: mediumGray,
    background: cream,
    surface: white,
    surfaceSecondary: "#F5F3F0",
    border: paleGray,
    borderLight: "#F0EEED",
    tabIconDefault: mediumGray,
    tabIconSelected: orange,
    tint: orange,
    success: green,
    error: red,
    critical: red,
    dot: "#E0DDD8",
    dotDone: orange,
    dotFail: lightGray,
    dotCritical: red,
    progressBg: paleGray,
    progressFill: orange,
    cardShadow: "rgba(0,0,0,0.04)",
  },
};

